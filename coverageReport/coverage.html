
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>assert: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stretchr/testify/assert/assertion_compare.go (100.0%)</option>
				
				<option value="file1">github.com/stretchr/testify/assert/assertion_format.go (1.3%)</option>
				
				<option value="file2">github.com/stretchr/testify/assert/assertion_forward.go (24.7%)</option>
				
				<option value="file3">github.com/stretchr/testify/assert/assertion_order.go (88.0%)</option>
				
				<option value="file4">github.com/stretchr/testify/assert/assertions.go (95.5%)</option>
				
				<option value="file5">github.com/stretchr/testify/assert/forward_assertions.go (100.0%)</option>
				
				<option value="file6">github.com/stretchr/testify/assert/http_assertions.go (90.8%)</option>
				
				<option value="file7">github.com/stretchr/testify/assert/yaml/yaml_default.go (100.0%)</option>
				
				<option value="file8">github.com/stretchr/testify/http/test_response_writer.go (0.0%)</option>
				
				<option value="file9">github.com/stretchr/testify/http/test_round_tripper.go (0.0%)</option>
				
				<option value="file10">github.com/stretchr/testify/mock/mock.go (94.1%)</option>
				
				<option value="file11">github.com/stretchr/testify/require/forward_requirements.go (100.0%)</option>
				
				<option value="file12">github.com/stretchr/testify/require/require.go (20.7%)</option>
				
				<option value="file13">github.com/stretchr/testify/require/require_forward.go (16.2%)</option>
				
				<option value="file14">github.com/stretchr/testify/suite/stats.go (100.0%)</option>
				
				<option value="file15">github.com/stretchr/testify/suite/suite.go (94.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package assert

import (
        "bytes"
        "fmt"
        "reflect"
        "time"
)

// Deprecated: CompareType has only ever been for internal use and has accidentally been published since v1.6.0. Do not use it.
type CompareType = compareResult

type compareResult int

const (
        compareLess compareResult = iota - 1
        compareEqual
        compareGreater
)

var (
        intType   = reflect.TypeOf(int(1))
        int8Type  = reflect.TypeOf(int8(1))
        int16Type = reflect.TypeOf(int16(1))
        int32Type = reflect.TypeOf(int32(1))
        int64Type = reflect.TypeOf(int64(1))

        uintType   = reflect.TypeOf(uint(1))
        uint8Type  = reflect.TypeOf(uint8(1))
        uint16Type = reflect.TypeOf(uint16(1))
        uint32Type = reflect.TypeOf(uint32(1))
        uint64Type = reflect.TypeOf(uint64(1))

        uintptrType = reflect.TypeOf(uintptr(1))

        float32Type = reflect.TypeOf(float32(1))
        float64Type = reflect.TypeOf(float64(1))

        stringType = reflect.TypeOf("")

        timeType  = reflect.TypeOf(time.Time{})
        bytesType = reflect.TypeOf([]byte{})
)

func compare(obj1, obj2 interface{}, kind reflect.Kind) (compareResult, bool) <span class="cov8" title="1">{
        obj1Value := reflect.ValueOf(obj1)
        obj2Value := reflect.ValueOf(obj2)

        // throughout this switch we try and avoid calling .Convert() if possible,
        // as this has a pretty big performance impact
        switch kind </span>{
        case reflect.Int:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        intobj1, ok := obj1.(int)
                        if !ok </span><span class="cov8" title="1">{
                                intobj1 = obj1Value.Convert(intType).Interface().(int)
                        }</span>
                        <span class="cov8" title="1">intobj2, ok := obj2.(int)
                        if !ok </span><span class="cov8" title="1">{
                                intobj2 = obj2Value.Convert(intType).Interface().(int)
                        }</span>
                        <span class="cov8" title="1">if intobj1 &gt; intobj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if intobj1 == intobj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if intobj1 &lt; intobj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Int8:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        int8obj1, ok := obj1.(int8)
                        if !ok </span><span class="cov8" title="1">{
                                int8obj1 = obj1Value.Convert(int8Type).Interface().(int8)
                        }</span>
                        <span class="cov8" title="1">int8obj2, ok := obj2.(int8)
                        if !ok </span><span class="cov8" title="1">{
                                int8obj2 = obj2Value.Convert(int8Type).Interface().(int8)
                        }</span>
                        <span class="cov8" title="1">if int8obj1 &gt; int8obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if int8obj1 == int8obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if int8obj1 &lt; int8obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Int16:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        int16obj1, ok := obj1.(int16)
                        if !ok </span><span class="cov8" title="1">{
                                int16obj1 = obj1Value.Convert(int16Type).Interface().(int16)
                        }</span>
                        <span class="cov8" title="1">int16obj2, ok := obj2.(int16)
                        if !ok </span><span class="cov8" title="1">{
                                int16obj2 = obj2Value.Convert(int16Type).Interface().(int16)
                        }</span>
                        <span class="cov8" title="1">if int16obj1 &gt; int16obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if int16obj1 == int16obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if int16obj1 &lt; int16obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Int32:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        int32obj1, ok := obj1.(int32)
                        if !ok </span><span class="cov8" title="1">{
                                int32obj1 = obj1Value.Convert(int32Type).Interface().(int32)
                        }</span>
                        <span class="cov8" title="1">int32obj2, ok := obj2.(int32)
                        if !ok </span><span class="cov8" title="1">{
                                int32obj2 = obj2Value.Convert(int32Type).Interface().(int32)
                        }</span>
                        <span class="cov8" title="1">if int32obj1 &gt; int32obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if int32obj1 == int32obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if int32obj1 &lt; int32obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Int64:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        int64obj1, ok := obj1.(int64)
                        if !ok </span><span class="cov8" title="1">{
                                int64obj1 = obj1Value.Convert(int64Type).Interface().(int64)
                        }</span>
                        <span class="cov8" title="1">int64obj2, ok := obj2.(int64)
                        if !ok </span><span class="cov8" title="1">{
                                int64obj2 = obj2Value.Convert(int64Type).Interface().(int64)
                        }</span>
                        <span class="cov8" title="1">if int64obj1 &gt; int64obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if int64obj1 == int64obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if int64obj1 &lt; int64obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Uint:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uintobj1, ok := obj1.(uint)
                        if !ok </span><span class="cov8" title="1">{
                                uintobj1 = obj1Value.Convert(uintType).Interface().(uint)
                        }</span>
                        <span class="cov8" title="1">uintobj2, ok := obj2.(uint)
                        if !ok </span><span class="cov8" title="1">{
                                uintobj2 = obj2Value.Convert(uintType).Interface().(uint)
                        }</span>
                        <span class="cov8" title="1">if uintobj1 &gt; uintobj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uintobj1 == uintobj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uintobj1 &lt; uintobj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Uint8:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uint8obj1, ok := obj1.(uint8)
                        if !ok </span><span class="cov8" title="1">{
                                uint8obj1 = obj1Value.Convert(uint8Type).Interface().(uint8)
                        }</span>
                        <span class="cov8" title="1">uint8obj2, ok := obj2.(uint8)
                        if !ok </span><span class="cov8" title="1">{
                                uint8obj2 = obj2Value.Convert(uint8Type).Interface().(uint8)
                        }</span>
                        <span class="cov8" title="1">if uint8obj1 &gt; uint8obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uint8obj1 == uint8obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uint8obj1 &lt; uint8obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Uint16:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uint16obj1, ok := obj1.(uint16)
                        if !ok </span><span class="cov8" title="1">{
                                uint16obj1 = obj1Value.Convert(uint16Type).Interface().(uint16)
                        }</span>
                        <span class="cov8" title="1">uint16obj2, ok := obj2.(uint16)
                        if !ok </span><span class="cov8" title="1">{
                                uint16obj2 = obj2Value.Convert(uint16Type).Interface().(uint16)
                        }</span>
                        <span class="cov8" title="1">if uint16obj1 &gt; uint16obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uint16obj1 == uint16obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uint16obj1 &lt; uint16obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Uint32:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uint32obj1, ok := obj1.(uint32)
                        if !ok </span><span class="cov8" title="1">{
                                uint32obj1 = obj1Value.Convert(uint32Type).Interface().(uint32)
                        }</span>
                        <span class="cov8" title="1">uint32obj2, ok := obj2.(uint32)
                        if !ok </span><span class="cov8" title="1">{
                                uint32obj2 = obj2Value.Convert(uint32Type).Interface().(uint32)
                        }</span>
                        <span class="cov8" title="1">if uint32obj1 &gt; uint32obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uint32obj1 == uint32obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uint32obj1 &lt; uint32obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Uint64:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uint64obj1, ok := obj1.(uint64)
                        if !ok </span><span class="cov8" title="1">{
                                uint64obj1 = obj1Value.Convert(uint64Type).Interface().(uint64)
                        }</span>
                        <span class="cov8" title="1">uint64obj2, ok := obj2.(uint64)
                        if !ok </span><span class="cov8" title="1">{
                                uint64obj2 = obj2Value.Convert(uint64Type).Interface().(uint64)
                        }</span>
                        <span class="cov8" title="1">if uint64obj1 &gt; uint64obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uint64obj1 == uint64obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uint64obj1 &lt; uint64obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Float32:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        float32obj1, ok := obj1.(float32)
                        if !ok </span><span class="cov8" title="1">{
                                float32obj1 = obj1Value.Convert(float32Type).Interface().(float32)
                        }</span>
                        <span class="cov8" title="1">float32obj2, ok := obj2.(float32)
                        if !ok </span><span class="cov8" title="1">{
                                float32obj2 = obj2Value.Convert(float32Type).Interface().(float32)
                        }</span>
                        <span class="cov8" title="1">if float32obj1 &gt; float32obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if float32obj1 == float32obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if float32obj1 &lt; float32obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.Float64:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        float64obj1, ok := obj1.(float64)
                        if !ok </span><span class="cov8" title="1">{
                                float64obj1 = obj1Value.Convert(float64Type).Interface().(float64)
                        }</span>
                        <span class="cov8" title="1">float64obj2, ok := obj2.(float64)
                        if !ok </span><span class="cov8" title="1">{
                                float64obj2 = obj2Value.Convert(float64Type).Interface().(float64)
                        }</span>
                        <span class="cov8" title="1">if float64obj1 &gt; float64obj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if float64obj1 == float64obj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if float64obj1 &lt; float64obj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        case reflect.String:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        stringobj1, ok := obj1.(string)
                        if !ok </span><span class="cov8" title="1">{
                                stringobj1 = obj1Value.Convert(stringType).Interface().(string)
                        }</span>
                        <span class="cov8" title="1">stringobj2, ok := obj2.(string)
                        if !ok </span><span class="cov8" title="1">{
                                stringobj2 = obj2Value.Convert(stringType).Interface().(string)
                        }</span>
                        <span class="cov8" title="1">if stringobj1 &gt; stringobj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if stringobj1 == stringobj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if stringobj1 &lt; stringobj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        // Check for known struct types we can check for compare results.
        case reflect.Struct:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        // All structs enter here. We're not interested in most types.
                        if !obj1Value.CanConvert(timeType) </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // time.Time can be compared!
                        <span class="cov8" title="1">timeObj1, ok := obj1.(time.Time)
                        if !ok </span><span class="cov8" title="1">{
                                timeObj1 = obj1Value.Convert(timeType).Interface().(time.Time)
                        }</span>

                        <span class="cov8" title="1">timeObj2, ok := obj2.(time.Time)
                        if !ok </span><span class="cov8" title="1">{
                                timeObj2 = obj2Value.Convert(timeType).Interface().(time.Time)
                        }</span>

                        <span class="cov8" title="1">if timeObj1.Before(timeObj2) </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                        <span class="cov8" title="1">if timeObj1.Equal(timeObj2) </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">return compareGreater, true</span>
                }
        case reflect.Slice:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        // We only care about the []byte type.
                        if !obj1Value.CanConvert(bytesType) </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // []byte can be compared!
                        <span class="cov8" title="1">bytesObj1, ok := obj1.([]byte)
                        if !ok </span><span class="cov8" title="1">{
                                bytesObj1 = obj1Value.Convert(bytesType).Interface().([]byte)

                        }</span>
                        <span class="cov8" title="1">bytesObj2, ok := obj2.([]byte)
                        if !ok </span><span class="cov8" title="1">{
                                bytesObj2 = obj2Value.Convert(bytesType).Interface().([]byte)
                        }</span>

                        <span class="cov8" title="1">return compareResult(bytes.Compare(bytesObj1, bytesObj2)), true</span>
                }
        case reflect.Uintptr:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        uintptrObj1, ok := obj1.(uintptr)
                        if !ok </span><span class="cov8" title="1">{
                                uintptrObj1 = obj1Value.Convert(uintptrType).Interface().(uintptr)
                        }</span>
                        <span class="cov8" title="1">uintptrObj2, ok := obj2.(uintptr)
                        if !ok </span><span class="cov8" title="1">{
                                uintptrObj2 = obj2Value.Convert(uintptrType).Interface().(uintptr)
                        }</span>
                        <span class="cov8" title="1">if uintptrObj1 &gt; uintptrObj2 </span><span class="cov8" title="1">{
                                return compareGreater, true
                        }</span>
                        <span class="cov8" title="1">if uintptrObj1 == uintptrObj2 </span><span class="cov8" title="1">{
                                return compareEqual, true
                        }</span>
                        <span class="cov8" title="1">if uintptrObj1 &lt; uintptrObj2 </span><span class="cov8" title="1">{
                                return compareLess, true
                        }</span>
                }
        }

        <span class="cov8" title="1">return compareEqual, false</span>
}

// Greater asserts that the first element is greater than the second
//
//        assert.Greater(t, 2, 1)
//        assert.Greater(t, float64(2), float64(1))
//        assert.Greater(t, "b", "a")
func Greater(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return compareTwoValues(t, e1, e2, []compareResult{compareGreater}, "\"%v\" is not greater than \"%v\"", msgAndArgs...)</span>
}

// GreaterOrEqual asserts that the first element is greater than or equal to the second
//
//        assert.GreaterOrEqual(t, 2, 1)
//        assert.GreaterOrEqual(t, 2, 2)
//        assert.GreaterOrEqual(t, "b", "a")
//        assert.GreaterOrEqual(t, "b", "b")
func GreaterOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return compareTwoValues(t, e1, e2, []compareResult{compareGreater, compareEqual}, "\"%v\" is not greater than or equal to \"%v\"", msgAndArgs...)</span>
}

// Less asserts that the first element is less than the second
//
//        assert.Less(t, 1, 2)
//        assert.Less(t, float64(1), float64(2))
//        assert.Less(t, "a", "b")
func Less(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return compareTwoValues(t, e1, e2, []compareResult{compareLess}, "\"%v\" is not less than \"%v\"", msgAndArgs...)</span>
}

// LessOrEqual asserts that the first element is less than or equal to the second
//
//        assert.LessOrEqual(t, 1, 2)
//        assert.LessOrEqual(t, 2, 2)
//        assert.LessOrEqual(t, "a", "b")
//        assert.LessOrEqual(t, "b", "b")
func LessOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return compareTwoValues(t, e1, e2, []compareResult{compareLess, compareEqual}, "\"%v\" is not less than or equal to \"%v\"", msgAndArgs...)</span>
}

// Positive asserts that the specified element is positive
//
//        assert.Positive(t, 1)
//        assert.Positive(t, 1.23)
func Positive(t TestingT, e interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">zero := reflect.Zero(reflect.TypeOf(e))
        return compareTwoValues(t, e, zero.Interface(), []compareResult{compareGreater}, "\"%v\" is not positive", msgAndArgs...)</span>
}

// Negative asserts that the specified element is negative
//
//        assert.Negative(t, -1)
//        assert.Negative(t, -1.23)
func Negative(t TestingT, e interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">zero := reflect.Zero(reflect.TypeOf(e))
        return compareTwoValues(t, e, zero.Interface(), []compareResult{compareLess}, "\"%v\" is not negative", msgAndArgs...)</span>
}

func compareTwoValues(t TestingT, e1 interface{}, e2 interface{}, allowedComparesResults []compareResult, failMessage string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">e1Kind := reflect.ValueOf(e1).Kind()
        e2Kind := reflect.ValueOf(e2).Kind()
        if e1Kind != e2Kind </span><span class="cov8" title="1">{
                return Fail(t, "Elements should be the same type", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">compareResult, isComparable := compare(e1, e2, e1Kind)
        if !isComparable </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Can not compare type \"%s\"", reflect.TypeOf(e1)), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if !containsValue(allowedComparesResults, compareResult) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf(failMessage, e1, e2), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

func containsValue(values []compareResult, value compareResult) bool <span class="cov8" title="1">{
        for _, v := range values </span><span class="cov8" title="1">{
                if v == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated with github.com/stretchr/testify/_codegen; DO NOT EDIT.

package assert

import (
        http "net/http"
        url "net/url"
        time "time"
)

// Conditionf uses a Comparison to assert a complex condition.
func Conditionf(t TestingT, comp Comparison, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Condition(t, comp, append([]interface{}{msg}, args...)...)</span>
}

// Containsf asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        assert.Containsf(t, "Hello World", "World", "error message %s", "formatted")
//        assert.Containsf(t, ["Hello", "World"], "World", "error message %s", "formatted")
//        assert.Containsf(t, {"Hello": "World"}, "Hello", "error message %s", "formatted")
func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Contains(t, s, contains, append([]interface{}{msg}, args...)...)</span>
}

// DirExistsf checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func DirExistsf(t TestingT, path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return DirExists(t, path, append([]interface{}{msg}, args...)...)</span>
}

// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)</span>
}

// Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        assert.Emptyf(t, obj, "error message %s", "formatted")
func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Empty(t, object, append([]interface{}{msg}, args...)...)</span>
}

// Equalf asserts that two objects are equal.
//
//        assert.Equalf(t, 123, 123, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Equal(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// EqualErrorf asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        assert.EqualErrorf(t, err,  expectedErrorString, "error message %s", "formatted")
func EqualErrorf(t TestingT, theError error, errString string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualError(t, theError, errString, append([]interface{}{msg}, args...)...)</span>
}

// EqualExportedValuesf asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         assert.EqualExportedValuesf(t, S{1, 2}, S{1, 3}, "error message %s", "formatted") =&gt; true
//         assert.EqualExportedValuesf(t, S{1, 2}, S{2, 3}, "error message %s", "formatted") =&gt; false
func EqualExportedValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualExportedValues(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// EqualValuesf asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        assert.EqualValuesf(t, uint32(123), int32(123), "error message %s", "formatted")
func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualValues(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// Errorf asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if assert.Errorf(t, err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedErrorf, err)
//          }
func Errorf(t TestingT, err error, msg string, args ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Error(t, err, append([]interface{}{msg}, args...)...)</span>
}

// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func ErrorAsf(t TestingT, err error, target interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorAs(t, err, target, append([]interface{}{msg}, args...)...)</span>
}

// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        assert.ErrorContainsf(t, err,  expectedErrorSubString, "error message %s", "formatted")
func ErrorContainsf(t TestingT, theError error, contains string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorContains(t, theError, contains, append([]interface{}{msg}, args...)...)</span>
}

// ErrorIsf asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func ErrorIsf(t TestingT, err error, target error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorIs(t, err, target, append([]interface{}{msg}, args...)...)</span>
}

// Eventuallyf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        assert.Eventuallyf(t, func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Eventually(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)</span>
}

// EventuallyWithTf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        assert.EventuallyWithTf(t, func(c *assert.CollectT, "error message %s", "formatted") {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func EventuallyWithTf(t TestingT, condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EventuallyWithT(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)</span>
}

// Exactlyf asserts that two objects are equal in value and type.
//
//        assert.Exactlyf(t, int32(123), int64(123), "error message %s", "formatted")
func Exactlyf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Exactly(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// Failf reports a failure through
func Failf(t TestingT, failureMessage string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Fail(t, failureMessage, append([]interface{}{msg}, args...)...)</span>
}

// FailNowf fails test
func FailNowf(t TestingT, failureMessage string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FailNow(t, failureMessage, append([]interface{}{msg}, args...)...)</span>
}

// Falsef asserts that the specified value is false.
//
//        assert.Falsef(t, myBool, "error message %s", "formatted")
func Falsef(t TestingT, value bool, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return False(t, value, append([]interface{}{msg}, args...)...)</span>
}

// FileExistsf checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func FileExistsf(t TestingT, path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FileExists(t, path, append([]interface{}{msg}, args...)...)</span>
}

// Greaterf asserts that the first element is greater than the second
//
//        assert.Greaterf(t, 2, 1, "error message %s", "formatted")
//        assert.Greaterf(t, float64(2), float64(1), "error message %s", "formatted")
//        assert.Greaterf(t, "b", "a", "error message %s", "formatted")
func Greaterf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Greater(t, e1, e2, append([]interface{}{msg}, args...)...)</span>
}

// GreaterOrEqualf asserts that the first element is greater than or equal to the second
//
//        assert.GreaterOrEqualf(t, 2, 1, "error message %s", "formatted")
//        assert.GreaterOrEqualf(t, 2, 2, "error message %s", "formatted")
//        assert.GreaterOrEqualf(t, "b", "a", "error message %s", "formatted")
//        assert.GreaterOrEqualf(t, "b", "b", "error message %s", "formatted")
func GreaterOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return GreaterOrEqual(t, e1, e2, append([]interface{}{msg}, args...)...)</span>
}

// HTTPBodyContainsf asserts that a specified handler returns a
// body that contains a string.
//
//        assert.HTTPBodyContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPBodyContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)</span>
}

// HTTPBodyNotContainsf asserts that a specified handler returns a
// body that does not contain a string.
//
//        assert.HTTPBodyNotContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPBodyNotContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)</span>
}

// HTTPErrorf asserts that a specified handler returns an error status code.
//
//        assert.HTTPErrorf(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPError(t, handler, method, url, values, append([]interface{}{msg}, args...)...)</span>
}

// HTTPRedirectf asserts that a specified handler returns a redirect status code.
//
//        assert.HTTPRedirectf(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPRedirect(t, handler, method, url, values, append([]interface{}{msg}, args...)...)</span>
}

// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
//        assert.HTTPStatusCodef(t, myHandler, "GET", "/notImplemented", nil, 501, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPStatusCodef(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPStatusCode(t, handler, method, url, values, statuscode, append([]interface{}{msg}, args...)...)</span>
}

// HTTPSuccessf asserts that a specified handler returns a success status code.
//
//        assert.HTTPSuccessf(t, myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPSuccessf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPSuccess(t, handler, method, url, values, append([]interface{}{msg}, args...)...)</span>
}

// Implementsf asserts that an object is implemented by the specified interface.
//
//        assert.Implementsf(t, (*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func Implementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Implements(t, interfaceObject, object, append([]interface{}{msg}, args...)...)</span>
}

// InDeltaf asserts that the two numerals are within delta of each other.
//
//        assert.InDeltaf(t, math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
func InDeltaf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDelta(t, expected, actual, delta, append([]interface{}{msg}, args...)...)</span>
}

// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func InDeltaMapValuesf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaMapValues(t, expected, actual, delta, append([]interface{}{msg}, args...)...)</span>
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
func InDeltaSlicef(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaSlice(t, expected, actual, delta, append([]interface{}{msg}, args...)...)</span>
}

// InEpsilonf asserts that expected and actual have a relative error less than epsilon
func InEpsilonf(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InEpsilon(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)</span>
}

// InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
func InEpsilonSlicef(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InEpsilonSlice(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)</span>
}

// IsDecreasingf asserts that the collection is decreasing
//
//        assert.IsDecreasingf(t, []int{2, 1, 0}, "error message %s", "formatted")
//        assert.IsDecreasingf(t, []float{2, 1}, "error message %s", "formatted")
//        assert.IsDecreasingf(t, []string{"b", "a"}, "error message %s", "formatted")
func IsDecreasingf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsDecreasing(t, object, append([]interface{}{msg}, args...)...)</span>
}

// IsIncreasingf asserts that the collection is increasing
//
//        assert.IsIncreasingf(t, []int{1, 2, 3}, "error message %s", "formatted")
//        assert.IsIncreasingf(t, []float{1, 2}, "error message %s", "formatted")
//        assert.IsIncreasingf(t, []string{"a", "b"}, "error message %s", "formatted")
func IsIncreasingf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsIncreasing(t, object, append([]interface{}{msg}, args...)...)</span>
}

// IsNonDecreasingf asserts that the collection is not decreasing
//
//        assert.IsNonDecreasingf(t, []int{1, 1, 2}, "error message %s", "formatted")
//        assert.IsNonDecreasingf(t, []float{1, 2}, "error message %s", "formatted")
//        assert.IsNonDecreasingf(t, []string{"a", "b"}, "error message %s", "formatted")
func IsNonDecreasingf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonDecreasing(t, object, append([]interface{}{msg}, args...)...)</span>
}

// IsNonIncreasingf asserts that the collection is not increasing
//
//        assert.IsNonIncreasingf(t, []int{2, 1, 1}, "error message %s", "formatted")
//        assert.IsNonIncreasingf(t, []float{2, 1}, "error message %s", "formatted")
//        assert.IsNonIncreasingf(t, []string{"b", "a"}, "error message %s", "formatted")
func IsNonIncreasingf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonIncreasing(t, object, append([]interface{}{msg}, args...)...)</span>
}

// IsTypef asserts that the specified objects are of the same type.
func IsTypef(t TestingT, expectedType interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsType(t, expectedType, object, append([]interface{}{msg}, args...)...)</span>
}

// JSONEqf asserts that two JSON strings are equivalent.
//
//        assert.JSONEqf(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
func JSONEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return JSONEq(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// Lenf asserts that the specified object has specific length.
// Lenf also fails if the object has a type that len() not accept.
//
//        assert.Lenf(t, mySlice, 3, "error message %s", "formatted")
func Lenf(t TestingT, object interface{}, length int, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Len(t, object, length, append([]interface{}{msg}, args...)...)</span>
}

// Lessf asserts that the first element is less than the second
//
//        assert.Lessf(t, 1, 2, "error message %s", "formatted")
//        assert.Lessf(t, float64(1), float64(2), "error message %s", "formatted")
//        assert.Lessf(t, "a", "b", "error message %s", "formatted")
func Lessf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Less(t, e1, e2, append([]interface{}{msg}, args...)...)</span>
}

// LessOrEqualf asserts that the first element is less than or equal to the second
//
//        assert.LessOrEqualf(t, 1, 2, "error message %s", "formatted")
//        assert.LessOrEqualf(t, 2, 2, "error message %s", "formatted")
//        assert.LessOrEqualf(t, "a", "b", "error message %s", "formatted")
//        assert.LessOrEqualf(t, "b", "b", "error message %s", "formatted")
func LessOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return LessOrEqual(t, e1, e2, append([]interface{}{msg}, args...)...)</span>
}

// Negativef asserts that the specified element is negative
//
//        assert.Negativef(t, -1, "error message %s", "formatted")
//        assert.Negativef(t, -1.23, "error message %s", "formatted")
func Negativef(t TestingT, e interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Negative(t, e, append([]interface{}{msg}, args...)...)</span>
}

// Neverf asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        assert.Neverf(t, func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func Neverf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Never(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)</span>
}

// Nilf asserts that the specified object is nil.
//
//        assert.Nilf(t, err, "error message %s", "formatted")
func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Nil(t, object, append([]interface{}{msg}, args...)...)</span>
}

// NoDirExistsf checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func NoDirExistsf(t TestingT, path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoDirExists(t, path, append([]interface{}{msg}, args...)...)</span>
}

// NoErrorf asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if assert.NoErrorf(t, err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func NoErrorf(t TestingT, err error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoError(t, err, append([]interface{}{msg}, args...)...)</span>
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func NoFileExistsf(t TestingT, path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoFileExists(t, path, append([]interface{}{msg}, args...)...)</span>
}

// NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        assert.NotContainsf(t, "Hello World", "Earth", "error message %s", "formatted")
//        assert.NotContainsf(t, ["Hello", "World"], "Earth", "error message %s", "formatted")
//        assert.NotContainsf(t, {"Hello": "World"}, "Earth", "error message %s", "formatted")
func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotContains(t, s, contains, append([]interface{}{msg}, args...)...)</span>
}

// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -&gt; false
//
// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -&gt; true
//
// assert.NotElementsMatchf(t, [1, 2, 3], [1, 2, 4], "error message %s", "formatted") -&gt; true
func NotElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)</span>
}

// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if assert.NotEmptyf(t, obj, "error message %s", "formatted") {
//          assert.Equal(t, "two", obj[1])
//        }
func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEmpty(t, object, append([]interface{}{msg}, args...)...)</span>
}

// NotEqualf asserts that the specified values are NOT equal.
//
//        assert.NotEqualf(t, obj1, obj2, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func NotEqualf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEqual(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
//
//        assert.NotEqualValuesf(t, obj1, obj2, "error message %s", "formatted")
func NotEqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEqualValues(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// NotErrorAsf asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func NotErrorAsf(t TestingT, err error, target interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorAs(t, err, target, append([]interface{}{msg}, args...)...)</span>
}

// NotErrorIsf asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func NotErrorIsf(t TestingT, err error, target error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorIs(t, err, target, append([]interface{}{msg}, args...)...)</span>
}

// NotImplementsf asserts that an object does not implement the specified interface.
//
//        assert.NotImplementsf(t, (*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func NotImplementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotImplements(t, interfaceObject, object, append([]interface{}{msg}, args...)...)</span>
}

// NotNilf asserts that the specified object is not nil.
//
//        assert.NotNilf(t, err, "error message %s", "formatted")
func NotNilf(t TestingT, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotNil(t, object, append([]interface{}{msg}, args...)...)</span>
}

// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        assert.NotPanicsf(t, func(){ RemainCalm() }, "error message %s", "formatted")
func NotPanicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotPanics(t, f, append([]interface{}{msg}, args...)...)</span>
}

// NotRegexpf asserts that a specified regexp does not match a string.
//
//        assert.NotRegexpf(t, regexp.MustCompile("starts"), "it's starting", "error message %s", "formatted")
//        assert.NotRegexpf(t, "^start", "it's not starting", "error message %s", "formatted")
func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotRegexp(t, rx, str, append([]interface{}{msg}, args...)...)</span>
}

// NotSamef asserts that two pointers do not reference the same object.
//
//        assert.NotSamef(t, ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func NotSamef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSame(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// NotSubsetf asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        assert.NotSubsetf(t, [1, 3, 4], [1, 2], "error message %s", "formatted")
//        assert.NotSubsetf(t, {"x": 1, "y": 2}, {"z": 3}, "error message %s", "formatted")
func NotSubsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSubset(t, list, subset, append([]interface{}{msg}, args...)...)</span>
}

// NotZerof asserts that i is not the zero value for its type.
func NotZerof(t TestingT, i interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotZero(t, i, append([]interface{}{msg}, args...)...)</span>
}

// Panicsf asserts that the code inside the specified PanicTestFunc panics.
//
//        assert.Panicsf(t, func(){ GoCrazy() }, "error message %s", "formatted")
func Panicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Panics(t, f, append([]interface{}{msg}, args...)...)</span>
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        assert.PanicsWithErrorf(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func PanicsWithErrorf(t TestingT, errString string, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithError(t, errString, f, append([]interface{}{msg}, args...)...)</span>
}

// PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        assert.PanicsWithValuef(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func PanicsWithValuef(t TestingT, expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithValue(t, expected, f, append([]interface{}{msg}, args...)...)</span>
}

// Positivef asserts that the specified element is positive
//
//        assert.Positivef(t, 1, "error message %s", "formatted")
//        assert.Positivef(t, 1.23, "error message %s", "formatted")
func Positivef(t TestingT, e interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Positive(t, e, append([]interface{}{msg}, args...)...)</span>
}

// Regexpf asserts that a specified regexp matches a string.
//
//        assert.Regexpf(t, regexp.MustCompile("start"), "it's starting", "error message %s", "formatted")
//        assert.Regexpf(t, "start...$", "it's not starting", "error message %s", "formatted")
func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Regexp(t, rx, str, append([]interface{}{msg}, args...)...)</span>
}

// Samef asserts that two pointers reference the same object.
//
//        assert.Samef(t, ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func Samef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Same(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// Subsetf asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        assert.Subsetf(t, [1, 2, 3], [1, 2], "error message %s", "formatted")
//        assert.Subsetf(t, {"x": 1, "y": 2}, {"x": 1}, "error message %s", "formatted")
func Subsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Subset(t, list, subset, append([]interface{}{msg}, args...)...)</span>
}

// Truef asserts that the specified value is true.
//
//        assert.Truef(t, myBool, "error message %s", "formatted")
func Truef(t TestingT, value bool, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return True(t, value, append([]interface{}{msg}, args...)...)</span>
}

// WithinDurationf asserts that the two times are within duration delta of each other.
//
//        assert.WithinDurationf(t, time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
func WithinDurationf(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return WithinDuration(t, expected, actual, delta, append([]interface{}{msg}, args...)...)</span>
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
//        assert.WithinRangef(t, time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second), "error message %s", "formatted")
func WithinRangef(t TestingT, actual time.Time, start time.Time, end time.Time, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return WithinRange(t, actual, start, end, append([]interface{}{msg}, args...)...)</span>
}

// YAMLEqf asserts that two YAML strings are equivalent.
func YAMLEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return YAMLEq(t, expected, actual, append([]interface{}{msg}, args...)...)</span>
}

// Zerof asserts that i is the zero value for its type.
func Zerof(t TestingT, i interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Zero(t, i, append([]interface{}{msg}, args...)...)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated with github.com/stretchr/testify/_codegen; DO NOT EDIT.

package assert

import (
        http "net/http"
        url "net/url"
        time "time"
)

// Condition uses a Comparison to assert a complex condition.
func (a *Assertions) Condition(comp Comparison, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Condition(a.t, comp, msgAndArgs...)</span>
}

// Conditionf uses a Comparison to assert a complex condition.
func (a *Assertions) Conditionf(comp Comparison, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Conditionf(a.t, comp, msg, args...)</span>
}

// Contains asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        a.Contains("Hello World", "World")
//        a.Contains(["Hello", "World"], "World")
//        a.Contains({"Hello": "World"}, "Hello")
func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Contains(a.t, s, contains, msgAndArgs...)</span>
}

// Containsf asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        a.Containsf("Hello World", "World", "error message %s", "formatted")
//        a.Containsf(["Hello", "World"], "World", "error message %s", "formatted")
//        a.Containsf({"Hello": "World"}, "Hello", "error message %s", "formatted")
func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Containsf(a.t, s, contains, msg, args...)</span>
}

// DirExists checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func (a *Assertions) DirExists(path string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return DirExists(a.t, path, msgAndArgs...)</span>
}

// DirExistsf checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return DirExistsf(a.t, path, msg, args...)</span>
}

// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ElementsMatch(a.t, listA, listB, msgAndArgs...)</span>
}

// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ElementsMatchf(a.t, listA, listB, msg, args...)</span>
}

// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        a.Empty(obj)
func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Empty(a.t, object, msgAndArgs...)</span>
}

// Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        a.Emptyf(obj, "error message %s", "formatted")
func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Emptyf(a.t, object, msg, args...)</span>
}

// Equal asserts that two objects are equal.
//
//        a.Equal(123, 123)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Equal(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualError asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        a.EqualError(err,  expectedErrorString)
func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return EqualError(a.t, theError, errString, msgAndArgs...)</span>
}

// EqualErrorf asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        a.EqualErrorf(err,  expectedErrorString, "error message %s", "formatted")
func (a *Assertions) EqualErrorf(theError error, errString string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualErrorf(a.t, theError, errString, msg, args...)</span>
}

// EqualExportedValues asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         a.EqualExportedValues(S{1, 2}, S{1, 3}) =&gt; true
//         a.EqualExportedValues(S{1, 2}, S{2, 3}) =&gt; false
func (a *Assertions) EqualExportedValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualExportedValues(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualExportedValuesf asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         a.EqualExportedValuesf(S{1, 2}, S{1, 3}, "error message %s", "formatted") =&gt; true
//         a.EqualExportedValuesf(S{1, 2}, S{2, 3}, "error message %s", "formatted") =&gt; false
func (a *Assertions) EqualExportedValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualExportedValuesf(a.t, expected, actual, msg, args...)</span>
}

// EqualValues asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        a.EqualValues(uint32(123), int32(123))
func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return EqualValues(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualValuesf asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        a.EqualValuesf(uint32(123), int32(123), "error message %s", "formatted")
func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EqualValuesf(a.t, expected, actual, msg, args...)</span>
}

// Equalf asserts that two objects are equal.
//
//        a.Equalf(123, 123, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Equalf(a.t, expected, actual, msg, args...)</span>
}

// Error asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.Error(err) {
//                   assert.Equal(t, expectedError, err)
//          }
func (a *Assertions) Error(err error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Error(a.t, err, msgAndArgs...)</span>
}

// ErrorAs asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func (a *Assertions) ErrorAs(err error, target interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorAs(a.t, err, target, msgAndArgs...)</span>
}

// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func (a *Assertions) ErrorAsf(err error, target interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorAsf(a.t, err, target, msg, args...)</span>
}

// ErrorContains asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        a.ErrorContains(err,  expectedErrorSubString)
func (a *Assertions) ErrorContains(theError error, contains string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return ErrorContains(a.t, theError, contains, msgAndArgs...)</span>
}

// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        a.ErrorContainsf(err,  expectedErrorSubString, "error message %s", "formatted")
func (a *Assertions) ErrorContainsf(theError error, contains string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorContainsf(a.t, theError, contains, msg, args...)</span>
}

// ErrorIs asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) ErrorIs(err error, target error, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorIs(a.t, err, target, msgAndArgs...)</span>
}

// ErrorIsf asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) ErrorIsf(err error, target error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return ErrorIsf(a.t, err, target, msg, args...)</span>
}

// Errorf asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.Errorf(err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedErrorf, err)
//          }
func (a *Assertions) Errorf(err error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Errorf(a.t, err, msg, args...)</span>
}

// Eventually asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Eventually(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// EventuallyWithT asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        a.EventuallyWithT(func(c *assert.CollectT) {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func (a *Assertions) EventuallyWithT(condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EventuallyWithT(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// EventuallyWithTf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        a.EventuallyWithTf(func(c *assert.CollectT, "error message %s", "formatted") {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func (a *Assertions) EventuallyWithTf(condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return EventuallyWithTf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Eventuallyf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        a.Eventuallyf(func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func (a *Assertions) Eventuallyf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Eventuallyf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Exactly asserts that two objects are equal in value and type.
//
//        a.Exactly(int32(123), int64(123))
func (a *Assertions) Exactly(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Exactly(a.t, expected, actual, msgAndArgs...)</span>
}

// Exactlyf asserts that two objects are equal in value and type.
//
//        a.Exactlyf(int32(123), int64(123), "error message %s", "formatted")
func (a *Assertions) Exactlyf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Exactlyf(a.t, expected, actual, msg, args...)</span>
}

// Fail reports a failure through
func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Fail(a.t, failureMessage, msgAndArgs...)</span>
}

// FailNow fails test
func (a *Assertions) FailNow(failureMessage string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FailNow(a.t, failureMessage, msgAndArgs...)</span>
}

// FailNowf fails test
func (a *Assertions) FailNowf(failureMessage string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FailNowf(a.t, failureMessage, msg, args...)</span>
}

// Failf reports a failure through
func (a *Assertions) Failf(failureMessage string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Failf(a.t, failureMessage, msg, args...)</span>
}

// False asserts that the specified value is false.
//
//        a.False(myBool)
func (a *Assertions) False(value bool, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return False(a.t, value, msgAndArgs...)</span>
}

// Falsef asserts that the specified value is false.
//
//        a.Falsef(myBool, "error message %s", "formatted")
func (a *Assertions) Falsef(value bool, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Falsef(a.t, value, msg, args...)</span>
}

// FileExists checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func (a *Assertions) FileExists(path string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FileExists(a.t, path, msgAndArgs...)</span>
}

// FileExistsf checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func (a *Assertions) FileExistsf(path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return FileExistsf(a.t, path, msg, args...)</span>
}

// Greater asserts that the first element is greater than the second
//
//        a.Greater(2, 1)
//        a.Greater(float64(2), float64(1))
//        a.Greater("b", "a")
func (a *Assertions) Greater(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Greater(a.t, e1, e2, msgAndArgs...)</span>
}

// GreaterOrEqual asserts that the first element is greater than or equal to the second
//
//        a.GreaterOrEqual(2, 1)
//        a.GreaterOrEqual(2, 2)
//        a.GreaterOrEqual("b", "a")
//        a.GreaterOrEqual("b", "b")
func (a *Assertions) GreaterOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return GreaterOrEqual(a.t, e1, e2, msgAndArgs...)</span>
}

// GreaterOrEqualf asserts that the first element is greater than or equal to the second
//
//        a.GreaterOrEqualf(2, 1, "error message %s", "formatted")
//        a.GreaterOrEqualf(2, 2, "error message %s", "formatted")
//        a.GreaterOrEqualf("b", "a", "error message %s", "formatted")
//        a.GreaterOrEqualf("b", "b", "error message %s", "formatted")
func (a *Assertions) GreaterOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return GreaterOrEqualf(a.t, e1, e2, msg, args...)</span>
}

// Greaterf asserts that the first element is greater than the second
//
//        a.Greaterf(2, 1, "error message %s", "formatted")
//        a.Greaterf(float64(2), float64(1), "error message %s", "formatted")
//        a.Greaterf("b", "a", "error message %s", "formatted")
func (a *Assertions) Greaterf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Greaterf(a.t, e1, e2, msg, args...)</span>
}

// HTTPBodyContains asserts that a specified handler returns a
// body that contains a string.
//
//        a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return HTTPBodyContains(a.t, handler, method, url, values, str, msgAndArgs...)</span>
}

// HTTPBodyContainsf asserts that a specified handler returns a
// body that contains a string.
//
//        a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPBodyContainsf(a.t, handler, method, url, values, str, msg, args...)</span>
}

// HTTPBodyNotContains asserts that a specified handler returns a
// body that does not contain a string.
//
//        a.HTTPBodyNotContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyNotContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return HTTPBodyNotContains(a.t, handler, method, url, values, str, msgAndArgs...)</span>
}

// HTTPBodyNotContainsf asserts that a specified handler returns a
// body that does not contain a string.
//
//        a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPBodyNotContainsf(a.t, handler, method, url, values, str, msg, args...)</span>
}

// HTTPError asserts that a specified handler returns an error status code.
//
//        a.HTTPError(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return HTTPError(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPErrorf asserts that a specified handler returns an error status code.
//
//        a.HTTPErrorf(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPErrorf(a.t, handler, method, url, values, msg, args...)</span>
}

// HTTPRedirect asserts that a specified handler returns a redirect status code.
//
//        a.HTTPRedirect(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return HTTPRedirect(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPRedirectf asserts that a specified handler returns a redirect status code.
//
//        a.HTTPRedirectf(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPRedirectf(a.t, handler, method, url, values, msg, args...)</span>
}

// HTTPStatusCode asserts that a specified handler returns a specified status code.
//
//        a.HTTPStatusCode(myHandler, "GET", "/notImplemented", nil, 501)
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPStatusCode(handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPStatusCode(a.t, handler, method, url, values, statuscode, msgAndArgs...)</span>
}

// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
//        a.HTTPStatusCodef(myHandler, "GET", "/notImplemented", nil, 501, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPStatusCodef(handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPStatusCodef(a.t, handler, method, url, values, statuscode, msg, args...)</span>
}

// HTTPSuccess asserts that a specified handler returns a success status code.
//
//        a.HTTPSuccess(myHandler, "POST", "http://www.google.com", nil)
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return HTTPSuccess(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPSuccessf asserts that a specified handler returns a success status code.
//
//        a.HTTPSuccessf(myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPSuccessf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return HTTPSuccessf(a.t, handler, method, url, values, msg, args...)</span>
}

// Implements asserts that an object is implemented by the specified interface.
//
//        a.Implements((*MyInterface)(nil), new(MyObject))
func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Implements(a.t, interfaceObject, object, msgAndArgs...)</span>
}

// Implementsf asserts that an object is implemented by the specified interface.
//
//        a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func (a *Assertions) Implementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Implementsf(a.t, interfaceObject, object, msg, args...)</span>
}

// InDelta asserts that the two numerals are within delta of each other.
//
//        a.InDelta(math.Pi, 22/7.0, 0.01)
func (a *Assertions) InDelta(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return InDelta(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (a *Assertions) InDeltaMapValues(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaMapValues(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (a *Assertions) InDeltaMapValuesf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaMapValuesf(a.t, expected, actual, delta, msg, args...)</span>
}

// InDeltaSlice is the same as InDelta, except it compares two slices.
func (a *Assertions) InDeltaSlice(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaSlice(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
func (a *Assertions) InDeltaSlicef(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaSlicef(a.t, expected, actual, delta, msg, args...)</span>
}

// InDeltaf asserts that the two numerals are within delta of each other.
//
//        a.InDeltaf(math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
func (a *Assertions) InDeltaf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InDeltaf(a.t, expected, actual, delta, msg, args...)</span>
}

// InEpsilon asserts that expected and actual have a relative error less than epsilon
func (a *Assertions) InEpsilon(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return InEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)</span>
}

// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func (a *Assertions) InEpsilonSlice(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InEpsilonSlice(a.t, expected, actual, epsilon, msgAndArgs...)</span>
}

// InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
func (a *Assertions) InEpsilonSlicef(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InEpsilonSlicef(a.t, expected, actual, epsilon, msg, args...)</span>
}

// InEpsilonf asserts that expected and actual have a relative error less than epsilon
func (a *Assertions) InEpsilonf(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return InEpsilonf(a.t, expected, actual, epsilon, msg, args...)</span>
}

// IsDecreasing asserts that the collection is decreasing
//
//        a.IsDecreasing([]int{2, 1, 0})
//        a.IsDecreasing([]float{2, 1})
//        a.IsDecreasing([]string{"b", "a"})
func (a *Assertions) IsDecreasing(object interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsDecreasing(a.t, object, msgAndArgs...)</span>
}

// IsDecreasingf asserts that the collection is decreasing
//
//        a.IsDecreasingf([]int{2, 1, 0}, "error message %s", "formatted")
//        a.IsDecreasingf([]float{2, 1}, "error message %s", "formatted")
//        a.IsDecreasingf([]string{"b", "a"}, "error message %s", "formatted")
func (a *Assertions) IsDecreasingf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsDecreasingf(a.t, object, msg, args...)</span>
}

// IsIncreasing asserts that the collection is increasing
//
//        a.IsIncreasing([]int{1, 2, 3})
//        a.IsIncreasing([]float{1, 2})
//        a.IsIncreasing([]string{"a", "b"})
func (a *Assertions) IsIncreasing(object interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsIncreasing(a.t, object, msgAndArgs...)</span>
}

// IsIncreasingf asserts that the collection is increasing
//
//        a.IsIncreasingf([]int{1, 2, 3}, "error message %s", "formatted")
//        a.IsIncreasingf([]float{1, 2}, "error message %s", "formatted")
//        a.IsIncreasingf([]string{"a", "b"}, "error message %s", "formatted")
func (a *Assertions) IsIncreasingf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsIncreasingf(a.t, object, msg, args...)</span>
}

// IsNonDecreasing asserts that the collection is not decreasing
//
//        a.IsNonDecreasing([]int{1, 1, 2})
//        a.IsNonDecreasing([]float{1, 2})
//        a.IsNonDecreasing([]string{"a", "b"})
func (a *Assertions) IsNonDecreasing(object interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonDecreasing(a.t, object, msgAndArgs...)</span>
}

// IsNonDecreasingf asserts that the collection is not decreasing
//
//        a.IsNonDecreasingf([]int{1, 1, 2}, "error message %s", "formatted")
//        a.IsNonDecreasingf([]float{1, 2}, "error message %s", "formatted")
//        a.IsNonDecreasingf([]string{"a", "b"}, "error message %s", "formatted")
func (a *Assertions) IsNonDecreasingf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonDecreasingf(a.t, object, msg, args...)</span>
}

// IsNonIncreasing asserts that the collection is not increasing
//
//        a.IsNonIncreasing([]int{2, 1, 1})
//        a.IsNonIncreasing([]float{2, 1})
//        a.IsNonIncreasing([]string{"b", "a"})
func (a *Assertions) IsNonIncreasing(object interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonIncreasing(a.t, object, msgAndArgs...)</span>
}

// IsNonIncreasingf asserts that the collection is not increasing
//
//        a.IsNonIncreasingf([]int{2, 1, 1}, "error message %s", "formatted")
//        a.IsNonIncreasingf([]float{2, 1}, "error message %s", "formatted")
//        a.IsNonIncreasingf([]string{"b", "a"}, "error message %s", "formatted")
func (a *Assertions) IsNonIncreasingf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsNonIncreasingf(a.t, object, msg, args...)</span>
}

// IsType asserts that the specified objects are of the same type.
func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return IsType(a.t, expectedType, object, msgAndArgs...)</span>
}

// IsTypef asserts that the specified objects are of the same type.
func (a *Assertions) IsTypef(expectedType interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return IsTypef(a.t, expectedType, object, msg, args...)</span>
}

// JSONEq asserts that two JSON strings are equivalent.
//
//        a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return JSONEq(a.t, expected, actual, msgAndArgs...)</span>
}

// JSONEqf asserts that two JSON strings are equivalent.
//
//        a.JSONEqf(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return JSONEqf(a.t, expected, actual, msg, args...)</span>
}

// Len asserts that the specified object has specific length.
// Len also fails if the object has a type that len() not accept.
//
//        a.Len(mySlice, 3)
func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Len(a.t, object, length, msgAndArgs...)</span>
}

// Lenf asserts that the specified object has specific length.
// Lenf also fails if the object has a type that len() not accept.
//
//        a.Lenf(mySlice, 3, "error message %s", "formatted")
func (a *Assertions) Lenf(object interface{}, length int, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Lenf(a.t, object, length, msg, args...)</span>
}

// Less asserts that the first element is less than the second
//
//        a.Less(1, 2)
//        a.Less(float64(1), float64(2))
//        a.Less("a", "b")
func (a *Assertions) Less(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Less(a.t, e1, e2, msgAndArgs...)</span>
}

// LessOrEqual asserts that the first element is less than or equal to the second
//
//        a.LessOrEqual(1, 2)
//        a.LessOrEqual(2, 2)
//        a.LessOrEqual("a", "b")
//        a.LessOrEqual("b", "b")
func (a *Assertions) LessOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return LessOrEqual(a.t, e1, e2, msgAndArgs...)</span>
}

// LessOrEqualf asserts that the first element is less than or equal to the second
//
//        a.LessOrEqualf(1, 2, "error message %s", "formatted")
//        a.LessOrEqualf(2, 2, "error message %s", "formatted")
//        a.LessOrEqualf("a", "b", "error message %s", "formatted")
//        a.LessOrEqualf("b", "b", "error message %s", "formatted")
func (a *Assertions) LessOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return LessOrEqualf(a.t, e1, e2, msg, args...)</span>
}

// Lessf asserts that the first element is less than the second
//
//        a.Lessf(1, 2, "error message %s", "formatted")
//        a.Lessf(float64(1), float64(2), "error message %s", "formatted")
//        a.Lessf("a", "b", "error message %s", "formatted")
func (a *Assertions) Lessf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Lessf(a.t, e1, e2, msg, args...)</span>
}

// Negative asserts that the specified element is negative
//
//        a.Negative(-1)
//        a.Negative(-1.23)
func (a *Assertions) Negative(e interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Negative(a.t, e, msgAndArgs...)</span>
}

// Negativef asserts that the specified element is negative
//
//        a.Negativef(-1, "error message %s", "formatted")
//        a.Negativef(-1.23, "error message %s", "formatted")
func (a *Assertions) Negativef(e interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Negativef(a.t, e, msg, args...)</span>
}

// Never asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
func (a *Assertions) Never(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Never(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// Neverf asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func (a *Assertions) Neverf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Neverf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Nil asserts that the specified object is nil.
//
//        a.Nil(err)
func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Nil(a.t, object, msgAndArgs...)</span>
}

// Nilf asserts that the specified object is nil.
//
//        a.Nilf(err, "error message %s", "formatted")
func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Nilf(a.t, object, msg, args...)</span>
}

// NoDirExists checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func (a *Assertions) NoDirExists(path string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoDirExists(a.t, path, msgAndArgs...)</span>
}

// NoDirExistsf checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func (a *Assertions) NoDirExistsf(path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoDirExistsf(a.t, path, msg, args...)</span>
}

// NoError asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.NoError(err) {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NoError(a.t, err, msgAndArgs...)</span>
}

// NoErrorf asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.NoErrorf(err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoErrorf(a.t, err, msg, args...)</span>
}

// NoFileExists checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func (a *Assertions) NoFileExists(path string, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoFileExists(a.t, path, msgAndArgs...)</span>
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func (a *Assertions) NoFileExistsf(path string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NoFileExistsf(a.t, path, msg, args...)</span>
}

// NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        a.NotContains("Hello World", "Earth")
//        a.NotContains(["Hello", "World"], "Earth")
//        a.NotContains({"Hello": "World"}, "Earth")
func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotContains(a.t, s, contains, msgAndArgs...)</span>
}

// NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        a.NotContainsf("Hello World", "Earth", "error message %s", "formatted")
//        a.NotContainsf(["Hello", "World"], "Earth", "error message %s", "formatted")
//        a.NotContainsf({"Hello": "World"}, "Earth", "error message %s", "formatted")
func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotContainsf(a.t, s, contains, msg, args...)</span>
}

// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// a.NotElementsMatch([1, 1, 2, 3], [1, 1, 2, 3]) -&gt; false
//
// a.NotElementsMatch([1, 1, 2, 3], [1, 2, 3]) -&gt; true
//
// a.NotElementsMatch([1, 2, 3], [1, 2, 4]) -&gt; true
func (a *Assertions) NotElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotElementsMatch(a.t, listA, listB, msgAndArgs...)</span>
}

// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// a.NotElementsMatchf([1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -&gt; false
//
// a.NotElementsMatchf([1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -&gt; true
//
// a.NotElementsMatchf([1, 2, 3], [1, 2, 4], "error message %s", "formatted") -&gt; true
func (a *Assertions) NotElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotElementsMatchf(a.t, listA, listB, msg, args...)</span>
}

// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if a.NotEmpty(obj) {
//          assert.Equal(t, "two", obj[1])
//        }
func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotEmpty(a.t, object, msgAndArgs...)</span>
}

// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if a.NotEmptyf(obj, "error message %s", "formatted") {
//          assert.Equal(t, "two", obj[1])
//        }
func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEmptyf(a.t, object, msg, args...)</span>
}

// NotEqual asserts that the specified values are NOT equal.
//
//        a.NotEqual(obj1, obj2)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotEqual(a.t, expected, actual, msgAndArgs...)</span>
}

// NotEqualValues asserts that two objects are not equal even when converted to the same type
//
//        a.NotEqualValues(obj1, obj2)
func (a *Assertions) NotEqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotEqualValues(a.t, expected, actual, msgAndArgs...)</span>
}

// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
//
//        a.NotEqualValuesf(obj1, obj2, "error message %s", "formatted")
func (a *Assertions) NotEqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEqualValuesf(a.t, expected, actual, msg, args...)</span>
}

// NotEqualf asserts that the specified values are NOT equal.
//
//        a.NotEqualf(obj1, obj2, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func (a *Assertions) NotEqualf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotEqualf(a.t, expected, actual, msg, args...)</span>
}

// NotErrorAs asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func (a *Assertions) NotErrorAs(err error, target interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorAs(a.t, err, target, msgAndArgs...)</span>
}

// NotErrorAsf asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func (a *Assertions) NotErrorAsf(err error, target interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorAsf(a.t, err, target, msg, args...)</span>
}

// NotErrorIs asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) NotErrorIs(err error, target error, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorIs(a.t, err, target, msgAndArgs...)</span>
}

// NotErrorIsf asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) NotErrorIsf(err error, target error, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotErrorIsf(a.t, err, target, msg, args...)</span>
}

// NotImplements asserts that an object does not implement the specified interface.
//
//        a.NotImplements((*MyInterface)(nil), new(MyObject))
func (a *Assertions) NotImplements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotImplements(a.t, interfaceObject, object, msgAndArgs...)</span>
}

// NotImplementsf asserts that an object does not implement the specified interface.
//
//        a.NotImplementsf((*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func (a *Assertions) NotImplementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotImplementsf(a.t, interfaceObject, object, msg, args...)</span>
}

// NotNil asserts that the specified object is not nil.
//
//        a.NotNil(err)
func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotNil(a.t, object, msgAndArgs...)</span>
}

// NotNilf asserts that the specified object is not nil.
//
//        a.NotNilf(err, "error message %s", "formatted")
func (a *Assertions) NotNilf(object interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotNilf(a.t, object, msg, args...)</span>
}

// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        a.NotPanics(func(){ RemainCalm() })
func (a *Assertions) NotPanics(f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotPanics(a.t, f, msgAndArgs...)</span>
}

// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        a.NotPanicsf(func(){ RemainCalm() }, "error message %s", "formatted")
func (a *Assertions) NotPanicsf(f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotPanicsf(a.t, f, msg, args...)</span>
}

// NotRegexp asserts that a specified regexp does not match a string.
//
//        a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
//        a.NotRegexp("^start", "it's not starting")
func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotRegexp(a.t, rx, str, msgAndArgs...)</span>
}

// NotRegexpf asserts that a specified regexp does not match a string.
//
//        a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %s", "formatted")
//        a.NotRegexpf("^start", "it's not starting", "error message %s", "formatted")
func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotRegexpf(a.t, rx, str, msg, args...)</span>
}

// NotSame asserts that two pointers do not reference the same object.
//
//        a.NotSame(ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) NotSame(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSame(a.t, expected, actual, msgAndArgs...)</span>
}

// NotSamef asserts that two pointers do not reference the same object.
//
//        a.NotSamef(ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) NotSamef(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSamef(a.t, expected, actual, msg, args...)</span>
}

// NotSubset asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        a.NotSubset([1, 3, 4], [1, 2])
//        a.NotSubset({"x": 1, "y": 2}, {"z": 3})
func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSubset(a.t, list, subset, msgAndArgs...)</span>
}

// NotSubsetf asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        a.NotSubsetf([1, 3, 4], [1, 2], "error message %s", "formatted")
//        a.NotSubsetf({"x": 1, "y": 2}, {"z": 3}, "error message %s", "formatted")
func (a *Assertions) NotSubsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotSubsetf(a.t, list, subset, msg, args...)</span>
}

// NotZero asserts that i is not the zero value for its type.
func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return NotZero(a.t, i, msgAndArgs...)</span>
}

// NotZerof asserts that i is not the zero value for its type.
func (a *Assertions) NotZerof(i interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return NotZerof(a.t, i, msg, args...)</span>
}

// Panics asserts that the code inside the specified PanicTestFunc panics.
//
//        a.Panics(func(){ GoCrazy() })
func (a *Assertions) Panics(f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Panics(a.t, f, msgAndArgs...)</span>
}

// PanicsWithError asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        a.PanicsWithError("crazy error", func(){ GoCrazy() })
func (a *Assertions) PanicsWithError(errString string, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithError(a.t, errString, f, msgAndArgs...)</span>
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        a.PanicsWithErrorf("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) PanicsWithErrorf(errString string, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithErrorf(a.t, errString, f, msg, args...)</span>
}

// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        a.PanicsWithValue("crazy error", func(){ GoCrazy() })
func (a *Assertions) PanicsWithValue(expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithValue(a.t, expected, f, msgAndArgs...)</span>
}

// PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) PanicsWithValuef(expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return PanicsWithValuef(a.t, expected, f, msg, args...)</span>
}

// Panicsf asserts that the code inside the specified PanicTestFunc panics.
//
//        a.Panicsf(func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) Panicsf(f PanicTestFunc, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Panicsf(a.t, f, msg, args...)</span>
}

// Positive asserts that the specified element is positive
//
//        a.Positive(1)
//        a.Positive(1.23)
func (a *Assertions) Positive(e interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Positive(a.t, e, msgAndArgs...)</span>
}

// Positivef asserts that the specified element is positive
//
//        a.Positivef(1, "error message %s", "formatted")
//        a.Positivef(1.23, "error message %s", "formatted")
func (a *Assertions) Positivef(e interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Positivef(a.t, e, msg, args...)</span>
}

// Regexp asserts that a specified regexp matches a string.
//
//        a.Regexp(regexp.MustCompile("start"), "it's starting")
//        a.Regexp("start...$", "it's not starting")
func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Regexp(a.t, rx, str, msgAndArgs...)</span>
}

// Regexpf asserts that a specified regexp matches a string.
//
//        a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %s", "formatted")
//        a.Regexpf("start...$", "it's not starting", "error message %s", "formatted")
func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Regexpf(a.t, rx, str, msg, args...)</span>
}

// Same asserts that two pointers reference the same object.
//
//        a.Same(ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) Same(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Same(a.t, expected, actual, msgAndArgs...)</span>
}

// Samef asserts that two pointers reference the same object.
//
//        a.Samef(ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) Samef(expected interface{}, actual interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Samef(a.t, expected, actual, msg, args...)</span>
}

// Subset asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        a.Subset([1, 2, 3], [1, 2])
//        a.Subset({"x": 1, "y": 2}, {"x": 1})
func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Subset(a.t, list, subset, msgAndArgs...)</span>
}

// Subsetf asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        a.Subsetf([1, 2, 3], [1, 2], "error message %s", "formatted")
//        a.Subsetf({"x": 1, "y": 2}, {"x": 1}, "error message %s", "formatted")
func (a *Assertions) Subsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Subsetf(a.t, list, subset, msg, args...)</span>
}

// True asserts that the specified value is true.
//
//        a.True(myBool)
func (a *Assertions) True(value bool, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return True(a.t, value, msgAndArgs...)</span>
}

// Truef asserts that the specified value is true.
//
//        a.Truef(myBool, "error message %s", "formatted")
func (a *Assertions) Truef(value bool, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Truef(a.t, value, msg, args...)</span>
}

// WithinDuration asserts that the two times are within duration delta of each other.
//
//        a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
func (a *Assertions) WithinDuration(expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return WithinDuration(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// WithinDurationf asserts that the two times are within duration delta of each other.
//
//        a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
func (a *Assertions) WithinDurationf(expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return WithinDurationf(a.t, expected, actual, delta, msg, args...)</span>
}

// WithinRange asserts that a time is within a time range (inclusive).
//
//        a.WithinRange(time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second))
func (a *Assertions) WithinRange(actual time.Time, start time.Time, end time.Time, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return WithinRange(a.t, actual, start, end, msgAndArgs...)</span>
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
//        a.WithinRangef(time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second), "error message %s", "formatted")
func (a *Assertions) WithinRangef(actual time.Time, start time.Time, end time.Time, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return WithinRangef(a.t, actual, start, end, msg, args...)</span>
}

// YAMLEq asserts that two YAML strings are equivalent.
func (a *Assertions) YAMLEq(expected string, actual string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return YAMLEq(a.t, expected, actual, msgAndArgs...)</span>
}

// YAMLEqf asserts that two YAML strings are equivalent.
func (a *Assertions) YAMLEqf(expected string, actual string, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return YAMLEqf(a.t, expected, actual, msg, args...)</span>
}

// Zero asserts that i is the zero value for its type.
func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Zero(a.t, i, msgAndArgs...)</span>
}

// Zerof asserts that i is the zero value for its type.
func (a *Assertions) Zerof(i interface{}, msg string, args ...interface{}) bool <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">return Zerof(a.t, i, msg, args...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package assert

import (
        "fmt"
        "reflect"
)

// isOrdered checks that collection contains orderable elements.
func isOrdered(t TestingT, object interface{}, allowedComparesResults []compareResult, failMessage string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        objKind := reflect.TypeOf(object).Kind()
        if objKind != reflect.Slice &amp;&amp; objKind != reflect.Array </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">objValue := reflect.ValueOf(object)
        objLen := objValue.Len()

        if objLen &lt;= 1 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">value := objValue.Index(0)
        valueInterface := value.Interface()
        firstValueKind := value.Kind()

        for i := 1; i &lt; objLen; i++ </span><span class="cov8" title="1">{
                prevValue := value
                prevValueInterface := valueInterface

                value = objValue.Index(i)
                valueInterface = value.Interface()

                compareResult, isComparable := compare(prevValueInterface, valueInterface, firstValueKind)

                if !isComparable </span><span class="cov0" title="0">{
                        return Fail(t, fmt.Sprintf("Can not compare type \"%s\" and \"%s\"", reflect.TypeOf(value), reflect.TypeOf(prevValue)), msgAndArgs...)
                }</span>

                <span class="cov8" title="1">if !containsValue(allowedComparesResults, compareResult) </span><span class="cov8" title="1">{
                        return Fail(t, fmt.Sprintf(failMessage, prevValue, value), msgAndArgs...)
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// IsIncreasing asserts that the collection is increasing
//
//        assert.IsIncreasing(t, []int{1, 2, 3})
//        assert.IsIncreasing(t, []float{1, 2})
//        assert.IsIncreasing(t, []string{"a", "b"})
func IsIncreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        return isOrdered(t, object, []compareResult{compareLess}, "\"%v\" is not less than \"%v\"", msgAndArgs...)
}</span>

// IsNonIncreasing asserts that the collection is not increasing
//
//        assert.IsNonIncreasing(t, []int{2, 1, 1})
//        assert.IsNonIncreasing(t, []float{2, 1})
//        assert.IsNonIncreasing(t, []string{"b", "a"})
func IsNonIncreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        return isOrdered(t, object, []compareResult{compareEqual, compareGreater}, "\"%v\" is not greater than or equal to \"%v\"", msgAndArgs...)
}</span>

// IsDecreasing asserts that the collection is decreasing
//
//        assert.IsDecreasing(t, []int{2, 1, 0})
//        assert.IsDecreasing(t, []float{2, 1})
//        assert.IsDecreasing(t, []string{"b", "a"})
func IsDecreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        return isOrdered(t, object, []compareResult{compareGreater}, "\"%v\" is not greater than \"%v\"", msgAndArgs...)
}</span>

// IsNonDecreasing asserts that the collection is not decreasing
//
//        assert.IsNonDecreasing(t, []int{1, 1, 2})
//        assert.IsNonDecreasing(t, []float{1, 2})
//        assert.IsNonDecreasing(t, []string{"a", "b"})
func IsNonDecreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        return isOrdered(t, object, []compareResult{compareLess, compareEqual}, "\"%v\" is not less than or equal to \"%v\"", msgAndArgs...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package assert

import (
        "bufio"
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "os"
        "reflect"
        "regexp"
        "runtime"
        "runtime/debug"
        "strings"
        "time"
        "unicode"
        "unicode/utf8"

        "github.com/davecgh/go-spew/spew"
        "github.com/pmezard/go-difflib/difflib"

        // Wrapper around gopkg.in/yaml.v3
        "github.com/stretchr/testify/assert/yaml"
)

//go:generate sh -c "cd ../_codegen &amp;&amp; go build &amp;&amp; cd - &amp;&amp; ../_codegen/_codegen -output-package=assert -template=assertion_format.go.tmpl"

// TestingT is an interface wrapper around *testing.T
type TestingT interface {
        Errorf(format string, args ...interface{})
}

// ComparisonAssertionFunc is a common function prototype when comparing two values.  Can be useful
// for table driven tests.
type ComparisonAssertionFunc func(TestingT, interface{}, interface{}, ...interface{}) bool

// ValueAssertionFunc is a common function prototype when validating a single value.  Can be useful
// for table driven tests.
type ValueAssertionFunc func(TestingT, interface{}, ...interface{}) bool

// BoolAssertionFunc is a common function prototype when validating a bool value.  Can be useful
// for table driven tests.
type BoolAssertionFunc func(TestingT, bool, ...interface{}) bool

// ErrorAssertionFunc is a common function prototype when validating an error value.  Can be useful
// for table driven tests.
type ErrorAssertionFunc func(TestingT, error, ...interface{}) bool

// PanicAssertionFunc is a common function prototype when validating a panic value.  Can be useful
// for table driven tests.
type PanicAssertionFunc = func(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool

// Comparison is a custom function that returns true on success and false on failure
type Comparison func() (success bool)

/*
        Helper functions
*/

// ObjectsAreEqual determines if two objects are considered equal.
//
// This function does no assertion of any kind.
func ObjectsAreEqual(expected, actual interface{}) bool <span class="cov8" title="1">{
        if expected == nil || actual == nil </span><span class="cov8" title="1">{
                return expected == actual
        }</span>

        <span class="cov8" title="1">exp, ok := expected.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return reflect.DeepEqual(expected, actual)
        }</span>

        <span class="cov8" title="1">act, ok := actual.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if exp == nil || act == nil </span><span class="cov8" title="1">{
                return exp == nil &amp;&amp; act == nil
        }</span>
        <span class="cov8" title="1">return bytes.Equal(exp, act)</span>
}

// copyExportedFields iterates downward through nested data structures and creates a copy
// that only contains the exported struct fields.
func copyExportedFields(expected interface{}) interface{} <span class="cov8" title="1">{
        if isNil(expected) </span><span class="cov8" title="1">{
                return expected
        }</span>

        <span class="cov8" title="1">expectedType := reflect.TypeOf(expected)
        expectedKind := expectedType.Kind()
        expectedValue := reflect.ValueOf(expected)

        switch expectedKind </span>{
        case reflect.Struct:<span class="cov8" title="1">
                result := reflect.New(expectedType).Elem()
                for i := 0; i &lt; expectedType.NumField(); i++ </span><span class="cov8" title="1">{
                        field := expectedType.Field(i)
                        isExported := field.IsExported()
                        if isExported </span><span class="cov8" title="1">{
                                fieldValue := expectedValue.Field(i)
                                if isNil(fieldValue) || isNil(fieldValue.Interface()) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">newValue := copyExportedFields(fieldValue.Interface())
                                result.Field(i).Set(reflect.ValueOf(newValue))</span>
                        }
                }
                <span class="cov8" title="1">return result.Interface()</span>

        case reflect.Ptr:<span class="cov8" title="1">
                result := reflect.New(expectedType.Elem())
                unexportedRemoved := copyExportedFields(expectedValue.Elem().Interface())
                result.Elem().Set(reflect.ValueOf(unexportedRemoved))
                return result.Interface()</span>

        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                var result reflect.Value
                if expectedKind == reflect.Array </span><span class="cov8" title="1">{
                        result = reflect.New(reflect.ArrayOf(expectedValue.Len(), expectedType.Elem())).Elem()
                }</span> else<span class="cov8" title="1"> {
                        result = reflect.MakeSlice(expectedType, expectedValue.Len(), expectedValue.Len())
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; expectedValue.Len(); i++ </span><span class="cov8" title="1">{
                        index := expectedValue.Index(i)
                        if isNil(index) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">unexportedRemoved := copyExportedFields(index.Interface())
                        result.Index(i).Set(reflect.ValueOf(unexportedRemoved))</span>
                }
                <span class="cov8" title="1">return result.Interface()</span>

        case reflect.Map:<span class="cov8" title="1">
                result := reflect.MakeMap(expectedType)
                for _, k := range expectedValue.MapKeys() </span><span class="cov8" title="1">{
                        index := expectedValue.MapIndex(k)
                        unexportedRemoved := copyExportedFields(index.Interface())
                        result.SetMapIndex(k, reflect.ValueOf(unexportedRemoved))
                }</span>
                <span class="cov8" title="1">return result.Interface()</span>

        default:<span class="cov8" title="1">
                return expected</span>
        }
}

// ObjectsExportedFieldsAreEqual determines if the exported (public) fields of two objects are
// considered equal. This comparison of only exported fields is applied recursively to nested data
// structures.
//
// This function does no assertion of any kind.
//
// Deprecated: Use [EqualExportedValues] instead.
func ObjectsExportedFieldsAreEqual(expected, actual interface{}) bool <span class="cov8" title="1">{
        expectedCleaned := copyExportedFields(expected)
        actualCleaned := copyExportedFields(actual)
        return ObjectsAreEqualValues(expectedCleaned, actualCleaned)
}</span>

// ObjectsAreEqualValues gets whether two objects are equal, or if their
// values are equal.
func ObjectsAreEqualValues(expected, actual interface{}) bool <span class="cov8" title="1">{
        if ObjectsAreEqual(expected, actual) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">expectedValue := reflect.ValueOf(expected)
        actualValue := reflect.ValueOf(actual)
        if !expectedValue.IsValid() || !actualValue.IsValid() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">expectedType := expectedValue.Type()
        actualType := actualValue.Type()
        if !expectedType.ConvertibleTo(actualType) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !isNumericType(expectedType) || !isNumericType(actualType) </span><span class="cov8" title="1">{
                // Attempt comparison after type conversion
                return reflect.DeepEqual(
                        expectedValue.Convert(actualType).Interface(), actual,
                )
        }</span>

        // If BOTH values are numeric, there are chances of false positives due
        // to overflow or underflow. So, we need to make sure to always convert
        // the smaller type to a larger type before comparing.
        <span class="cov8" title="1">if expectedType.Size() &gt;= actualType.Size() </span><span class="cov8" title="1">{
                return actualValue.Convert(expectedType).Interface() == expected
        }</span>

        <span class="cov8" title="1">return expectedValue.Convert(actualType).Interface() == actual</span>
}

// isNumericType returns true if the type is one of:
// int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64,
// float32, float64, complex64, complex128
func isNumericType(t reflect.Type) bool <span class="cov8" title="1">{
        return t.Kind() &gt;= reflect.Int &amp;&amp; t.Kind() &lt;= reflect.Complex128
}</span>

/* CallerInfo is necessary because the assert functions use the testing object
internally, causing it to print the file:line of the assert method, rather than where
the problem actually occurred in calling code.*/

// CallerInfo returns an array of strings containing the file and line number
// of each stack frame leading from the current test to the assert call that
// failed.
func CallerInfo() []string <span class="cov8" title="1">{

        var pc uintptr
        var ok bool
        var file string
        var line int
        var name string

        callers := []string{}
        for i := 0; ; i++ </span><span class="cov8" title="1">{
                pc, file, line, ok = runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        // The breaks below failed to terminate the loop, and we ran off the
                        // end of the call stack.
                        break</span>
                }

                // This is a huge edge case, but it will panic if this is the case, see #180
                <span class="cov8" title="1">if file == "&lt;autogenerated&gt;" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">f := runtime.FuncForPC(pc)
                if f == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">name = f.Name()

                // testing.tRunner is the standard library function that calls
                // tests. Subtests are called directly by tRunner, without going through
                // the Test/Benchmark/Example function that contains the t.Run calls, so
                // with subtests we should break when we hit tRunner, without adding it
                // to the list of callers.
                if name == "testing.tRunner" </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">parts := strings.Split(file, "/")
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        filename := parts[len(parts)-1]
                        dir := parts[len(parts)-2]
                        if (dir != "assert" &amp;&amp; dir != "mock" &amp;&amp; dir != "require") || filename == "mock_test.go" </span><span class="cov8" title="1">{
                                callers = append(callers, fmt.Sprintf("%s:%d", file, line))
                        }</span>
                }

                // Drop the package
                <span class="cov8" title="1">segments := strings.Split(name, ".")
                name = segments[len(segments)-1]
                if isTest(name, "Test") ||
                        isTest(name, "Benchmark") ||
                        isTest(name, "Example") </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return callers</span>
}

// Stolen from the `go test` tool.
// isTest tells whether name looks like a test (or benchmark, according to prefix).
// It is a Test (say) if there is a character after Test that is not a lower-case letter.
// We don't want TesticularCancer.
func isTest(name, prefix string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(name, prefix) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(name) == len(prefix) </span><span class="cov0" title="0">{ // "Test" is ok
                return true
        }</span>
        <span class="cov8" title="1">r, _ := utf8.DecodeRuneInString(name[len(prefix):])
        return !unicode.IsLower(r)</span>
}

func messageFromMsgAndArgs(msgAndArgs ...interface{}) string <span class="cov8" title="1">{
        if len(msgAndArgs) == 0 || msgAndArgs == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(msgAndArgs) == 1 </span><span class="cov8" title="1">{
                msg := msgAndArgs[0]
                if msgAsStr, ok := msg.(string); ok </span><span class="cov8" title="1">{
                        return msgAsStr
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%+v", msg)</span>
        }
        <span class="cov8" title="1">if len(msgAndArgs) &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Sprintf(msgAndArgs[0].(string), msgAndArgs[1:]...)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Aligns the provided message so that all lines after the first line start at the same location as the first line.
// Assumes that the first line starts at the correct location (after carriage return, tab, label, spacer and tab).
// The longestLabelLen parameter specifies the length of the longest label in the output (required because this is the
// basis on which the alignment occurs).
func indentMessageLines(message string, longestLabelLen int) string <span class="cov8" title="1">{
        outBuf := new(bytes.Buffer)

        for i, scanner := 0, bufio.NewScanner(strings.NewReader(message)); scanner.Scan(); i++ </span><span class="cov8" title="1">{
                // no need to align first line because it starts at the correct location (after the label)
                if i != 0 </span><span class="cov8" title="1">{
                        // append alignLen+1 spaces to align with "{{longestLabel}}:" before adding tab
                        outBuf.WriteString("\n\t" + strings.Repeat(" ", longestLabelLen+1) + "\t")
                }</span>
                <span class="cov8" title="1">outBuf.WriteString(scanner.Text())</span>
        }

        <span class="cov8" title="1">return outBuf.String()</span>
}

type failNower interface {
        FailNow()
}

// FailNow fails test
func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Fail(t, failureMessage, msgAndArgs...)

        // We cannot extend TestingT with FailNow() and
        // maintain backwards compatibility, so we fallback
        // to panicking when FailNow is not available in
        // TestingT.
        // See issue #263

        if t, ok := t.(failNower); ok </span><span class="cov8" title="1">{
                t.FailNow()
        }</span> else<span class="cov8" title="1"> {
                panic("test failed and t is missing `FailNow()`")</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Fail reports a failure through
func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">content := []labeledContent{
                {"Error Trace", strings.Join(CallerInfo(), "\n\t\t\t")},
                {"Error", failureMessage},
        }

        // Add test name if the Go version supports it
        if n, ok := t.(interface {
                Name() string
        }); ok </span><span class="cov8" title="1">{
                content = append(content, labeledContent{"Test", n.Name()})
        }</span>

        <span class="cov8" title="1">message := messageFromMsgAndArgs(msgAndArgs...)
        if len(message) &gt; 0 </span><span class="cov8" title="1">{
                content = append(content, labeledContent{"Messages", message})
        }</span>

        <span class="cov8" title="1">t.Errorf("\n%s", ""+labeledOutput(content...))

        return false</span>
}

type labeledContent struct {
        label   string
        content string
}

// labeledOutput returns a string consisting of the provided labeledContent. Each labeled output is appended in the following manner:
//
//        \t{{label}}:{{align_spaces}}\t{{content}}\n
//
// The initial carriage return is required to undo/erase any padding added by testing.T.Errorf. The "\t{{label}}:" is for the label.
// If a label is shorter than the longest label provided, padding spaces are added to make all the labels match in length. Once this
// alignment is achieved, "\t{{content}}\n" is added for the output.
//
// If the content of the labeledOutput contains line breaks, the subsequent lines are aligned so that they start at the same location as the first line.
func labeledOutput(content ...labeledContent) string <span class="cov8" title="1">{
        longestLabel := 0
        for _, v := range content </span><span class="cov8" title="1">{
                if len(v.label) &gt; longestLabel </span><span class="cov8" title="1">{
                        longestLabel = len(v.label)
                }</span>
        }
        <span class="cov8" title="1">var output string
        for _, v := range content </span><span class="cov8" title="1">{
                output += "\t" + v.label + ":" + strings.Repeat(" ", longestLabel-len(v.label)) + "\t" + indentMessageLines(v.content, longestLabel) + "\n"
        }</span>
        <span class="cov8" title="1">return output</span>
}

// Implements asserts that an object is implemented by the specified interface.
//
//        assert.Implements(t, (*MyInterface)(nil), new(MyObject))
func Implements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">interfaceType := reflect.TypeOf(interfaceObject).Elem()

        if object == nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Cannot check if nil implements %v", interfaceType), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if !reflect.TypeOf(object).Implements(interfaceType) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%T must implement %v", object, interfaceType), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// NotImplements asserts that an object does not implement the specified interface.
//
//        assert.NotImplements(t, (*MyInterface)(nil), new(MyObject))
func NotImplements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">interfaceType := reflect.TypeOf(interfaceObject).Elem()

        if object == nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Cannot check if nil does not implement %v", interfaceType), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if reflect.TypeOf(object).Implements(interfaceType) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%T implements %v", object, interfaceType), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// IsType asserts that the specified objects are of the same type.
func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if !ObjectsAreEqual(reflect.TypeOf(object), reflect.TypeOf(expectedType)) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Object expected to be of type %v, but was %v", reflect.TypeOf(expectedType), reflect.TypeOf(object)), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Equal asserts that two objects are equal.
//
//        assert.Equal(t, 123, 123)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if err := validateEqualArgs(expected, actual); err != nil </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("Invalid operation: %#v == %#v (%s)",
                        expected, actual, err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if !ObjectsAreEqual(expected, actual) </span><span class="cov8" title="1">{
                diff := diff(expected, actual)
                expected, actual = formatUnequalValues(expected, actual)
                return Fail(t, fmt.Sprintf("Not equal: \n"+
                        "expected: %s\n"+
                        "actual  : %s%s", expected, actual, diff), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>

}

// validateEqualArgs checks whether provided arguments can be safely used in the
// Equal/NotEqual functions.
func validateEqualArgs(expected, actual interface{}) error <span class="cov8" title="1">{
        if expected == nil &amp;&amp; actual == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if isFunction(expected) || isFunction(actual) </span><span class="cov8" title="1">{
                return errors.New("cannot take func type as argument")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Same asserts that two pointers reference the same object.
//
//        assert.Same(t, ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func Same(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">same, ok := samePointers(expected, actual)
        if !ok </span><span class="cov8" title="1">{
                return Fail(t, "Both arguments must be pointers", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if !same </span><span class="cov8" title="1">{
                // both are pointers but not the same type &amp; pointing to the same address
                return Fail(t, fmt.Sprintf("Not same: \n"+
                        "expected: %p %#v\n"+
                        "actual  : %p %#v", expected, expected, actual, actual), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// NotSame asserts that two pointers do not reference the same object.
//
//        assert.NotSame(t, ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func NotSame(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">same, ok := samePointers(expected, actual)
        if !ok </span><span class="cov8" title="1">{
                //fails when the arguments are not pointers
                return !(Fail(t, "Both arguments must be pointers", msgAndArgs...))
        }</span>

        <span class="cov8" title="1">if same </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf(
                        "Expected and actual point to the same object: %p %#v",
                        expected, expected), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// samePointers checks if two generic interface objects are pointers of the same
// type pointing to the same object. It returns two values: same indicating if
// they are the same type and point to the same object, and ok indicating that
// both inputs are pointers.
func samePointers(first, second interface{}) (same bool, ok bool) <span class="cov8" title="1">{
        firstPtr, secondPtr := reflect.ValueOf(first), reflect.ValueOf(second)
        if firstPtr.Kind() != reflect.Ptr || secondPtr.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                return false, false //not both are pointers
        }</span>

        <span class="cov8" title="1">firstType, secondType := reflect.TypeOf(first), reflect.TypeOf(second)
        if firstType != secondType </span><span class="cov0" title="0">{
                return false, true // both are pointers, but of different types
        }</span>

        // compare pointer addresses
        <span class="cov8" title="1">return first == second, true</span>
}

// formatUnequalValues takes two values of arbitrary types and returns string
// representations appropriate to be presented to the user.
//
// If the values are not of like type, the returned strings will be prefixed
// with the type name, and the value will be enclosed in parentheses similar
// to a type conversion in the Go grammar.
func formatUnequalValues(expected, actual interface{}) (e string, a string) <span class="cov8" title="1">{
        if reflect.TypeOf(expected) != reflect.TypeOf(actual) </span><span class="cov8" title="1">{
                return fmt.Sprintf("%T(%s)", expected, truncatingFormat(expected)),
                        fmt.Sprintf("%T(%s)", actual, truncatingFormat(actual))
        }</span>
        <span class="cov8" title="1">switch expected.(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                return fmt.Sprintf("%v", expected), fmt.Sprintf("%v", actual)</span>
        }
        <span class="cov8" title="1">return truncatingFormat(expected), truncatingFormat(actual)</span>
}

// truncatingFormat formats the data and truncates it if it's too long.
//
// This helps keep formatted error messages lines from exceeding the
// bufio.MaxScanTokenSize max line length that the go testing framework imposes.
func truncatingFormat(data interface{}) string <span class="cov8" title="1">{
        value := fmt.Sprintf("%#v", data)
        max := bufio.MaxScanTokenSize - 100 // Give us some space the type info too if needed.
        if len(value) &gt; max </span><span class="cov8" title="1">{
                value = value[0:max] + "&lt;... truncated&gt;"
        }</span>
        <span class="cov8" title="1">return value</span>
}

// EqualValues asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        assert.EqualValues(t, uint32(123), int32(123))
func EqualValues(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if !ObjectsAreEqualValues(expected, actual) </span><span class="cov0" title="0">{
                diff := diff(expected, actual)
                expected, actual = formatUnequalValues(expected, actual)
                return Fail(t, fmt.Sprintf("Not equal: \n"+
                        "expected: %s\n"+
                        "actual  : %s%s", expected, actual, diff), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>

}

// EqualExportedValues asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         assert.EqualExportedValues(t, S{1, 2}, S{1, 3}) =&gt; true
//         assert.EqualExportedValues(t, S{1, 2}, S{2, 3}) =&gt; false
func EqualExportedValues(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">aType := reflect.TypeOf(expected)
        bType := reflect.TypeOf(actual)

        if aType != bType </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("Types expected to match exactly\n\t%v != %v", aType, bType), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">expected = copyExportedFields(expected)
        actual = copyExportedFields(actual)

        if !ObjectsAreEqualValues(expected, actual) </span><span class="cov8" title="1">{
                diff := diff(expected, actual)
                expected, actual = formatUnequalValues(expected, actual)
                return Fail(t, fmt.Sprintf("Not equal (comparing only exported fields): \n"+
                        "expected: %s\n"+
                        "actual  : %s%s", expected, actual, diff), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Exactly asserts that two objects are equal in value and type.
//
//        assert.Exactly(t, int32(123), int64(123))
func Exactly(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">aType := reflect.TypeOf(expected)
        bType := reflect.TypeOf(actual)

        if aType != bType </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Types expected to match exactly\n\t%v != %v", aType, bType), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return Equal(t, expected, actual, msgAndArgs...)</span>

}

// NotNil asserts that the specified object is not nil.
//
//        assert.NotNil(t, err)
func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if !isNil(object) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Fail(t, "Expected value not to be nil.", msgAndArgs...)</span>
}

// isNil checks if a specified object is nil or not, without Failing.
func isNil(object interface{}) bool <span class="cov8" title="1">{
        if object == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">value := reflect.ValueOf(object)
        switch value.Kind() </span>{
        case
                reflect.Chan, reflect.Func,
                reflect.Interface, reflect.Map,
                reflect.Ptr, reflect.Slice, reflect.UnsafePointer:<span class="cov8" title="1">

                return value.IsNil()</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Nil asserts that the specified object is nil.
//
//        assert.Nil(t, err)
func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if isNil(object) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">return Fail(t, fmt.Sprintf("Expected nil, but got: %#v", object), msgAndArgs...)</span>
}

// isEmpty gets whether the specified object is considered empty or not.
func isEmpty(object interface{}) bool <span class="cov8" title="1">{

        // get nil case out of the way
        if object == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">objValue := reflect.ValueOf(object)

        switch objValue.Kind() </span>{
        // collection types are empty when they have no element
        case reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                return objValue.Len() == 0</span>
        // pointers are empty if nil or if the value they point to is empty
        case reflect.Ptr:<span class="cov8" title="1">
                if objValue.IsNil() </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">deref := objValue.Elem().Interface()
                return isEmpty(deref)</span>
        // for all other types, compare against the zero value
        // array types are empty when they match their zero-initialized state
        default:<span class="cov8" title="1">
                zero := reflect.Zero(objValue.Type())
                return reflect.DeepEqual(object, zero.Interface())</span>
        }
}

// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        assert.Empty(t, obj)
func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        pass := isEmpty(object)
        if !pass </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">Fail(t, fmt.Sprintf("Should be empty, but was %v", object), msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return pass</span>

}

// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if assert.NotEmpty(t, obj) {
//          assert.Equal(t, "two", obj[1])
//        }
func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        pass := !isEmpty(object)
        if !pass </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">Fail(t, fmt.Sprintf("Should NOT be empty, but was %v", object), msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return pass</span>

}

// getLen tries to get the length of an object.
// It returns (0, false) if impossible.
func getLen(x interface{}) (length int, ok bool) <span class="cov8" title="1">{
        v := reflect.ValueOf(x)
        defer func() </span><span class="cov8" title="1">{
                ok = recover() == nil
        }</span>()
        <span class="cov8" title="1">return v.Len(), true</span>
}

// Len asserts that the specified object has specific length.
// Len also fails if the object has a type that len() not accept.
//
//        assert.Len(t, mySlice, 3)
func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">l, ok := getLen(object)
        if !ok </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("\"%v\" could not be applied builtin len()", object), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if l != length </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("\"%v\" should have %d item(s), but has %d", object, length, l), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// True asserts that the specified value is true.
//
//        assert.True(t, myBool)
func True(t TestingT, value bool, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if !value </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">return Fail(t, "Should be true", msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return true</span>

}

// False asserts that the specified value is false.
//
//        assert.False(t, myBool)
func False(t TestingT, value bool, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">return Fail(t, "Should be false", msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return true</span>

}

// NotEqual asserts that the specified values are NOT equal.
//
//        assert.NotEqual(t, obj1, obj2)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func NotEqual(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if err := validateEqualArgs(expected, actual); err != nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Invalid operation: %#v != %#v (%s)",
                        expected, actual, err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if ObjectsAreEqual(expected, actual) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Should not be: %#v\n", actual), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>

}

// NotEqualValues asserts that two objects are not equal even when converted to the same type
//
//        assert.NotEqualValues(t, obj1, obj2)
func NotEqualValues(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if ObjectsAreEqualValues(expected, actual) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Should not be: %#v\n", actual), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// containsElement try loop over the list check if the list includes the element.
// return (false, false) if impossible.
// return (true, false) if element was not found.
// return (true, true) if element was found.
func containsElement(list interface{}, element interface{}) (ok, found bool) <span class="cov8" title="1">{

        listValue := reflect.ValueOf(list)
        listType := reflect.TypeOf(list)
        if listType == nil </span><span class="cov8" title="1">{
                return false, false
        }</span>
        <span class="cov8" title="1">listKind := listType.Kind()
        defer func() </span><span class="cov8" title="1">{
                if e := recover(); e != nil </span><span class="cov8" title="1">{
                        ok = false
                        found = false
                }</span>
        }()

        <span class="cov8" title="1">if listKind == reflect.String </span><span class="cov8" title="1">{
                elementValue := reflect.ValueOf(element)
                return true, strings.Contains(listValue.String(), elementValue.String())
        }</span>

        <span class="cov8" title="1">if listKind == reflect.Map </span><span class="cov8" title="1">{
                mapKeys := listValue.MapKeys()
                for i := 0; i &lt; len(mapKeys); i++ </span><span class="cov8" title="1">{
                        if ObjectsAreEqual(mapKeys[i].Interface(), element) </span><span class="cov8" title="1">{
                                return true, true
                        }</span>
                }
                <span class="cov8" title="1">return true, false</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; listValue.Len(); i++ </span><span class="cov8" title="1">{
                if ObjectsAreEqual(listValue.Index(i).Interface(), element) </span><span class="cov8" title="1">{
                        return true, true
                }</span>
        }
        <span class="cov8" title="1">return true, false</span>

}

// Contains asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        assert.Contains(t, "Hello World", "World")
//        assert.Contains(t, ["Hello", "World"], "World")
//        assert.Contains(t, {"Hello": "World"}, "Hello")
func Contains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">ok, found := containsElement(s, contains)
        if !ok </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%#v could not be applied builtin len()", s), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%#v does not contain %#v", s, contains), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>

}

// NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        assert.NotContains(t, "Hello World", "Earth")
//        assert.NotContains(t, ["Hello", "World"], "Earth")
//        assert.NotContains(t, {"Hello": "World"}, "Earth")
func NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">ok, found := containsElement(s, contains)
        if !ok </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%#v could not be applied builtin len()", s), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%#v should not contain %#v", s, contains), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>

}

// Subset asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        assert.Subset(t, [1, 2, 3], [1, 2])
//        assert.Subset(t, {"x": 1, "y": 2}, {"x": 1})
func Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if subset == nil </span><span class="cov8" title="1">{
                return true // we consider nil to be equal to the nil set
        }</span>

        <span class="cov8" title="1">listKind := reflect.TypeOf(list).Kind()
        if listKind != reflect.Array &amp;&amp; listKind != reflect.Slice &amp;&amp; listKind != reflect.Map </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("%q has an unsupported type %s", list, listKind), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">subsetKind := reflect.TypeOf(subset).Kind()
        if subsetKind != reflect.Array &amp;&amp; subsetKind != reflect.Slice &amp;&amp; listKind != reflect.Map </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("%q has an unsupported type %s", subset, subsetKind), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if subsetKind == reflect.Map &amp;&amp; listKind == reflect.Map </span><span class="cov8" title="1">{
                subsetMap := reflect.ValueOf(subset)
                actualMap := reflect.ValueOf(list)

                for _, k := range subsetMap.MapKeys() </span><span class="cov8" title="1">{
                        ev := subsetMap.MapIndex(k)
                        av := actualMap.MapIndex(k)

                        if !av.IsValid() </span><span class="cov8" title="1">{
                                return Fail(t, fmt.Sprintf("%#v does not contain %#v", list, subset), msgAndArgs...)
                        }</span>
                        <span class="cov8" title="1">if !ObjectsAreEqual(ev.Interface(), av.Interface()) </span><span class="cov8" title="1">{
                                return Fail(t, fmt.Sprintf("%#v does not contain %#v", list, subset), msgAndArgs...)
                        }</span>
                }

                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">subsetList := reflect.ValueOf(subset)
        for i := 0; i &lt; subsetList.Len(); i++ </span><span class="cov8" title="1">{
                element := subsetList.Index(i).Interface()
                ok, found := containsElement(list, element)
                if !ok </span><span class="cov0" title="0">{
                        return Fail(t, fmt.Sprintf("%#v could not be applied builtin len()", list), msgAndArgs...)
                }</span>
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return Fail(t, fmt.Sprintf("%#v does not contain %#v", list, element), msgAndArgs...)
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// NotSubset asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        assert.NotSubset(t, [1, 3, 4], [1, 2])
//        assert.NotSubset(t, {"x": 1, "y": 2}, {"z": 3})
func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if subset == nil </span><span class="cov8" title="1">{
                return Fail(t, "nil is the empty set which is a subset of every set", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">listKind := reflect.TypeOf(list).Kind()
        if listKind != reflect.Array &amp;&amp; listKind != reflect.Slice &amp;&amp; listKind != reflect.Map </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("%q has an unsupported type %s", list, listKind), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">subsetKind := reflect.TypeOf(subset).Kind()
        if subsetKind != reflect.Array &amp;&amp; subsetKind != reflect.Slice &amp;&amp; listKind != reflect.Map </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("%q has an unsupported type %s", subset, subsetKind), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if subsetKind == reflect.Map &amp;&amp; listKind == reflect.Map </span><span class="cov8" title="1">{
                subsetMap := reflect.ValueOf(subset)
                actualMap := reflect.ValueOf(list)

                for _, k := range subsetMap.MapKeys() </span><span class="cov8" title="1">{
                        ev := subsetMap.MapIndex(k)
                        av := actualMap.MapIndex(k)

                        if !av.IsValid() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">if !ObjectsAreEqual(ev.Interface(), av.Interface()) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }

                <span class="cov8" title="1">return Fail(t, fmt.Sprintf("%q is a subset of %q", subset, list), msgAndArgs...)</span>
        }

        <span class="cov8" title="1">subsetList := reflect.ValueOf(subset)
        for i := 0; i &lt; subsetList.Len(); i++ </span><span class="cov8" title="1">{
                element := subsetList.Index(i).Interface()
                ok, found := containsElement(list, element)
                if !ok </span><span class="cov0" title="0">{
                        return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", list), msgAndArgs...)
                }</span>
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return Fail(t, fmt.Sprintf("%q is a subset of %q", subset, list), msgAndArgs...)</span>
}

// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2])
func ElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if isEmpty(listA) &amp;&amp; isEmpty(listB) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if !isList(t, listA, msgAndArgs...) || !isList(t, listB, msgAndArgs...) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">extraA, extraB := diffLists(listA, listB)

        if len(extraA) == 0 &amp;&amp; len(extraB) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return Fail(t, formatListDiff(listA, listB, extraA, extraB), msgAndArgs...)</span>
}

// isList checks that the provided value is array or slice.
func isList(t TestingT, list interface{}, msgAndArgs ...interface{}) (ok bool) <span class="cov8" title="1">{
        kind := reflect.TypeOf(list).Kind()
        if kind != reflect.Array &amp;&amp; kind != reflect.Slice </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("%q has an unsupported type %s, expecting array or slice", list, kind),
                        msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// diffLists diffs two arrays/slices and returns slices of elements that are only in A and only in B.
// If some element is present multiple times, each instance is counted separately (e.g. if something is 2x in A and
// 5x in B, it will be 0x in extraA and 3x in extraB). The order of items in both lists is ignored.
func diffLists(listA, listB interface{}) (extraA, extraB []interface{}) <span class="cov8" title="1">{
        aValue := reflect.ValueOf(listA)
        bValue := reflect.ValueOf(listB)

        aLen := aValue.Len()
        bLen := bValue.Len()

        // Mark indexes in bValue that we already used
        visited := make([]bool, bLen)
        for i := 0; i &lt; aLen; i++ </span><span class="cov8" title="1">{
                element := aValue.Index(i).Interface()
                found := false
                for j := 0; j &lt; bLen; j++ </span><span class="cov8" title="1">{
                        if visited[j] </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if ObjectsAreEqual(bValue.Index(j).Interface(), element) </span><span class="cov8" title="1">{
                                visited[j] = true
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        extraA = append(extraA, element)
                }</span>
        }

        <span class="cov8" title="1">for j := 0; j &lt; bLen; j++ </span><span class="cov8" title="1">{
                if visited[j] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">extraB = append(extraB, bValue.Index(j).Interface())</span>
        }

        <span class="cov8" title="1">return</span>
}

func formatListDiff(listA, listB interface{}, extraA, extraB []interface{}) string <span class="cov8" title="1">{
        var msg bytes.Buffer

        msg.WriteString("elements differ")
        if len(extraA) &gt; 0 </span><span class="cov8" title="1">{
                msg.WriteString("\n\nextra elements in list A:\n")
                msg.WriteString(spewConfig.Sdump(extraA))
        }</span>
        <span class="cov8" title="1">if len(extraB) &gt; 0 </span><span class="cov8" title="1">{
                msg.WriteString("\n\nextra elements in list B:\n")
                msg.WriteString(spewConfig.Sdump(extraB))
        }</span>
        <span class="cov8" title="1">msg.WriteString("\n\nlistA:\n")
        msg.WriteString(spewConfig.Sdump(listA))
        msg.WriteString("\n\nlistB:\n")
        msg.WriteString(spewConfig.Sdump(listB))

        return msg.String()</span>
}

// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 1, 2, 3]) -&gt; false
//
// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 2, 3]) -&gt; true
//
// assert.NotElementsMatch(t, [1, 2, 3], [1, 2, 4]) -&gt; true
func NotElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if isEmpty(listA) &amp;&amp; isEmpty(listB) </span><span class="cov8" title="1">{
                return Fail(t, "listA and listB contain the same elements", msgAndArgs)
        }</span>

        <span class="cov8" title="1">if !isList(t, listA, msgAndArgs...) </span><span class="cov0" title="0">{
                return Fail(t, "listA is not a list type", msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if !isList(t, listB, msgAndArgs...) </span><span class="cov0" title="0">{
                return Fail(t, "listB is not a list type", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">extraA, extraB := diffLists(listA, listB)
        if len(extraA) == 0 &amp;&amp; len(extraB) == 0 </span><span class="cov8" title="1">{
                return Fail(t, "listA and listB contain the same elements", msgAndArgs)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Condition uses a Comparison to assert a complex condition.
func Condition(t TestingT, comp Comparison, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">result := comp()
        if !result </span><span class="cov8" title="1">{
                Fail(t, "Condition failed!", msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// PanicTestFunc defines a func that should be passed to the assert.Panics and assert.NotPanics
// methods, and represents a simple func that takes no arguments, and returns nothing.
type PanicTestFunc func()

// didPanic returns true if the function passed to it panics. Otherwise, it returns false.
func didPanic(f PanicTestFunc) (didPanic bool, message interface{}, stack string) <span class="cov8" title="1">{
        didPanic = true

        defer func() </span><span class="cov8" title="1">{
                message = recover()
                if didPanic </span><span class="cov8" title="1">{
                        stack = string(debug.Stack())
                }</span>
        }()

        // call the target function
        <span class="cov8" title="1">f()
        didPanic = false

        return</span>
}

// Panics asserts that the code inside the specified PanicTestFunc panics.
//
//        assert.Panics(t, func(){ GoCrazy() })
func Panics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if funcDidPanic, panicValue, _ := didPanic(f); !funcDidPanic </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        assert.PanicsWithValue(t, "crazy error", func(){ GoCrazy() })
func PanicsWithValue(t TestingT, expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">funcDidPanic, panicValue, panickedStack := didPanic(f)
        if !funcDidPanic </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if panicValue != expected </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should panic with value:\t%#v\n\tPanic value:\t%#v\n\tPanic stack:\t%s", f, expected, panicValue, panickedStack), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// PanicsWithError asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        assert.PanicsWithError(t, "crazy error", func(){ GoCrazy() })
func PanicsWithError(t TestingT, errString string, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">funcDidPanic, panicValue, panickedStack := didPanic(f)
        if !funcDidPanic </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">panicErr, ok := panicValue.(error)
        if !ok || panicErr.Error() != errString </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should panic with error message:\t%#v\n\tPanic value:\t%#v\n\tPanic stack:\t%s", f, errString, panicValue, panickedStack), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        assert.NotPanics(t, func(){ RemainCalm() })
func NotPanics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if funcDidPanic, panicValue, panickedStack := didPanic(f); funcDidPanic </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("func %#v should not panic\n\tPanic value:\t%v\n\tPanic stack:\t%s", f, panicValue, panickedStack), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// WithinDuration asserts that the two times are within duration delta of each other.
//
//        assert.WithinDuration(t, time.Now(), time.Now(), 10*time.Second)
func WithinDuration(t TestingT, expected, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">dt := expected.Sub(actual)
        if dt &lt; -delta || dt &gt; delta </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Max difference between %v and %v allowed is %v, but difference was %v", expected, actual, delta, dt), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// WithinRange asserts that a time is within a time range (inclusive).
//
//        assert.WithinRange(t, time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second))
func WithinRange(t TestingT, actual, start, end time.Time, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if end.Before(start) </span><span class="cov8" title="1">{
                return Fail(t, "Start should be before end", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if actual.Before(start) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Time %v expected to be in time range %v to %v, but is before the range", actual, start, end), msgAndArgs...)
        }</span> else<span class="cov8" title="1"> if actual.After(end) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Time %v expected to be in time range %v to %v, but is after the range", actual, start, end), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

func toFloat(x interface{}) (float64, bool) <span class="cov8" title="1">{
        var xf float64
        xok := true

        switch xn := x.(type) </span>{
        case uint:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case uint8:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case uint16:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case uint32:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case uint64:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case int:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case int8:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case int16:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case int32:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case int64:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case float32:<span class="cov8" title="1">
                xf = float64(xn)</span>
        case float64:<span class="cov8" title="1">
                xf = xn</span>
        case time.Duration:<span class="cov8" title="1">
                xf = float64(xn)</span>
        default:<span class="cov8" title="1">
                xok = false</span>
        }

        <span class="cov8" title="1">return xf, xok</span>
}

// InDelta asserts that the two numerals are within delta of each other.
//
//        assert.InDelta(t, math.Pi, 22/7.0, 0.01)
func InDelta(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">af, aok := toFloat(expected)
        bf, bok := toFloat(actual)

        if !aok || !bok </span><span class="cov8" title="1">{
                return Fail(t, "Parameters must be numerical", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if math.IsNaN(af) &amp;&amp; math.IsNaN(bf) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if math.IsNaN(af) </span><span class="cov8" title="1">{
                return Fail(t, "Expected must not be NaN", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if math.IsNaN(bf) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Expected %v with delta %v, but was NaN", expected, delta), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">dt := af - bf
        if dt &lt; -delta || dt &gt; delta </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Max difference between %v and %v allowed is %v, but difference was %v", expected, actual, delta, dt), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// InDeltaSlice is the same as InDelta, except it compares two slices.
func InDeltaSlice(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if expected == nil || actual == nil ||
                reflect.TypeOf(actual).Kind() != reflect.Slice ||
                reflect.TypeOf(expected).Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return Fail(t, "Parameters must be slice", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">actualSlice := reflect.ValueOf(actual)
        expectedSlice := reflect.ValueOf(expected)

        for i := 0; i &lt; actualSlice.Len(); i++ </span><span class="cov8" title="1">{
                result := InDelta(t, actualSlice.Index(i).Interface(), expectedSlice.Index(i).Interface(), delta, msgAndArgs...)
                if !result </span><span class="cov8" title="1">{
                        return result
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func InDeltaMapValues(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if expected == nil || actual == nil ||
                reflect.TypeOf(actual).Kind() != reflect.Map ||
                reflect.TypeOf(expected).Kind() != reflect.Map </span><span class="cov0" title="0">{
                return Fail(t, "Arguments must be maps", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">expectedMap := reflect.ValueOf(expected)
        actualMap := reflect.ValueOf(actual)

        if expectedMap.Len() != actualMap.Len() </span><span class="cov8" title="1">{
                return Fail(t, "Arguments must have the same number of keys", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">for _, k := range expectedMap.MapKeys() </span><span class="cov8" title="1">{
                ev := expectedMap.MapIndex(k)
                av := actualMap.MapIndex(k)

                if !ev.IsValid() </span><span class="cov0" title="0">{
                        return Fail(t, fmt.Sprintf("missing key %q in expected map", k), msgAndArgs...)
                }</span>

                <span class="cov8" title="1">if !av.IsValid() </span><span class="cov8" title="1">{
                        return Fail(t, fmt.Sprintf("missing key %q in actual map", k), msgAndArgs...)
                }</span>

                <span class="cov8" title="1">if !InDelta(
                        t,
                        ev.Interface(),
                        av.Interface(),
                        delta,
                        msgAndArgs...,
                ) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func calcRelativeError(expected, actual interface{}) (float64, error) <span class="cov8" title="1">{
        af, aok := toFloat(expected)
        bf, bok := toFloat(actual)
        if !aok || !bok </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("Parameters must be numerical")
        }</span>
        <span class="cov8" title="1">if math.IsNaN(af) &amp;&amp; math.IsNaN(bf) </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">if math.IsNaN(af) </span><span class="cov8" title="1">{
                return 0, errors.New("expected value must not be NaN")
        }</span>
        <span class="cov8" title="1">if af == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("expected value must have a value other than zero to calculate the relative error")
        }</span>
        <span class="cov8" title="1">if math.IsNaN(bf) </span><span class="cov0" title="0">{
                return 0, errors.New("actual value must not be NaN")
        }</span>

        <span class="cov8" title="1">return math.Abs(af-bf) / math.Abs(af), nil</span>
}

// InEpsilon asserts that expected and actual have a relative error less than epsilon
func InEpsilon(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if math.IsNaN(epsilon) </span><span class="cov8" title="1">{
                return Fail(t, "epsilon must not be NaN", msgAndArgs...)
        }</span>
        <span class="cov8" title="1">actualEpsilon, err := calcRelativeError(expected, actual)
        if err != nil </span><span class="cov8" title="1">{
                return Fail(t, err.Error(), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if math.IsNaN(actualEpsilon) </span><span class="cov8" title="1">{
                return Fail(t, "relative error is NaN", msgAndArgs...)
        }</span>
        <span class="cov8" title="1">if actualEpsilon &gt; epsilon </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Relative error is too high: %#v (expected)\n"+
                        "        &lt; %#v (actual)", epsilon, actualEpsilon), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func InEpsilonSlice(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">if expected == nil || actual == nil </span><span class="cov8" title="1">{
                return Fail(t, "Parameters must be slice", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">expectedSlice := reflect.ValueOf(expected)
        actualSlice := reflect.ValueOf(actual)

        if expectedSlice.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return Fail(t, "Expected value must be slice", msgAndArgs...)
        }</span>

        <span class="cov8" title="1">expectedLen := expectedSlice.Len()
        if !IsType(t, expected, actual) || !Len(t, actual, expectedLen) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; expectedLen; i++ </span><span class="cov8" title="1">{
                if !InEpsilon(t, expectedSlice.Index(i).Interface(), actualSlice.Index(i).Interface(), epsilon, "at index %d", i) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

/*
        Errors
*/

// NoError asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if assert.NoError(t, err) {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func NoError(t TestingT, err error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">return Fail(t, fmt.Sprintf("Received unexpected error:\n%+v", err), msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Error asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if assert.Error(t, err) {
//                   assert.Equal(t, expectedError, err)
//          }
func Error(t TestingT, err error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                        h.Helper()
                }</span>
                <span class="cov8" title="1">return Fail(t, "An error is expected but got nil.", msgAndArgs...)</span>
        }

        <span class="cov8" title="1">return true</span>
}

// EqualError asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        assert.EqualError(t, err,  expectedErrorString)
func EqualError(t TestingT, theError error, errString string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if !Error(t, theError, msgAndArgs...) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">expected := errString
        actual := theError.Error()
        // don't need to use deep equals here, we know they are both strings
        if expected != actual </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Error message not equal:\n"+
                        "expected: %q\n"+
                        "actual  : %q", expected, actual), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// ErrorContains asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        assert.ErrorContains(t, err,  expectedErrorSubString)
func ErrorContains(t TestingT, theError error, contains string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if !Error(t, theError, msgAndArgs...) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">actual := theError.Error()
        if !strings.Contains(actual, contains) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Error %#v does not contain %#v", actual, contains), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// matchRegexp return true if a specified regexp matches a string.
func matchRegexp(rx interface{}, str interface{}) bool <span class="cov8" title="1">{
        var r *regexp.Regexp
        if rr, ok := rx.(*regexp.Regexp); ok </span><span class="cov8" title="1">{
                r = rr
        }</span> else<span class="cov8" title="1"> {
                r = regexp.MustCompile(fmt.Sprint(rx))
        }</span>

        <span class="cov8" title="1">switch v := str.(type) </span>{
        case []byte:<span class="cov8" title="1">
                return r.Match(v)</span>
        case string:<span class="cov8" title="1">
                return r.MatchString(v)</span>
        default:<span class="cov0" title="0">
                return r.MatchString(fmt.Sprint(v))</span>
        }

}

// Regexp asserts that a specified regexp matches a string.
//
//        assert.Regexp(t, regexp.MustCompile("start"), "it's starting")
//        assert.Regexp(t, "start...$", "it's not starting")
func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">match := matchRegexp(rx, str)

        if !match </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expect \"%v\" to match \"%v\"", str, rx), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return match</span>
}

// NotRegexp asserts that a specified regexp does not match a string.
//
//        assert.NotRegexp(t, regexp.MustCompile("starts"), "it's starting")
//        assert.NotRegexp(t, "^start", "it's not starting")
func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">match := matchRegexp(rx, str)

        if match </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expect \"%v\" to NOT match \"%v\"", str, rx), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return !match</span>

}

// Zero asserts that i is the zero value for its type.
func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if i != nil &amp;&amp; !reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Should be zero, but was %v", i), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NotZero asserts that i is not the zero value for its type.
func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if i == nil || reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Should not be zero, but was %v", i), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// FileExists checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return Fail(t, fmt.Sprintf("unable to find file %q", path), msgAndArgs...)
                }</span>
                <span class="cov0" title="0">return Fail(t, fmt.Sprintf("error when running os.Lstat(%q): %s", path, err), msgAndArgs...)</span>
        }
        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%q is a directory", path), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NoFileExists checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func NoFileExists(t TestingT, path string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return Fail(t, fmt.Sprintf("file %q exists", path), msgAndArgs...)</span>
}

// DirExists checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return Fail(t, fmt.Sprintf("unable to find file %q", path), msgAndArgs...)
                }</span>
                <span class="cov0" title="0">return Fail(t, fmt.Sprintf("error when running os.Lstat(%q): %s", path, err), msgAndArgs...)</span>
        }
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("%q is a file", path), msgAndArgs...)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NoDirExists checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func NoDirExists(t TestingT, path string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return Fail(t, fmt.Sprintf("directory %q exists", path), msgAndArgs...)</span>
}

// JSONEq asserts that two JSON strings are equivalent.
//
//        assert.JSONEq(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
func JSONEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">var expectedJSONAsInterface, actualJSONAsInterface interface{}

        if err := json.Unmarshal([]byte(expected), &amp;expectedJSONAsInterface); err != nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Expected value ('%s') is not valid json.\nJSON parsing error: '%s'", expected, err.Error()), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal([]byte(actual), &amp;actualJSONAsInterface); err != nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Input ('%s') needs to be valid json.\nJSON parsing error: '%s'", actual, err.Error()), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return Equal(t, expectedJSONAsInterface, actualJSONAsInterface, msgAndArgs...)</span>
}

// YAMLEq asserts that two YAML strings are equivalent.
func YAMLEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">var expectedYAMLAsInterface, actualYAMLAsInterface interface{}

        if err := yaml.Unmarshal([]byte(expected), &amp;expectedYAMLAsInterface); err != nil </span><span class="cov0" title="0">{
                return Fail(t, fmt.Sprintf("Expected value ('%s') is not valid yaml.\nYAML parsing error: '%s'", expected, err.Error()), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">if err := yaml.Unmarshal([]byte(actual), &amp;actualYAMLAsInterface); err != nil </span><span class="cov8" title="1">{
                return Fail(t, fmt.Sprintf("Input ('%s') needs to be valid yaml.\nYAML error: '%s'", actual, err.Error()), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return Equal(t, expectedYAMLAsInterface, actualYAMLAsInterface, msgAndArgs...)</span>
}

func typeAndKind(v interface{}) (reflect.Type, reflect.Kind) <span class="cov8" title="1">{
        t := reflect.TypeOf(v)
        k := t.Kind()

        if k == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
                k = t.Kind()
        }</span>
        <span class="cov8" title="1">return t, k</span>
}

// diff returns a diff of both values as long as both are of the same type and
// are a struct, map, slice, array or string. Otherwise it returns an empty string.
func diff(expected interface{}, actual interface{}) string <span class="cov8" title="1">{
        if expected == nil || actual == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">et, ek := typeAndKind(expected)
        at, _ := typeAndKind(actual)

        if et != at </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if ek != reflect.Struct &amp;&amp; ek != reflect.Map &amp;&amp; ek != reflect.Slice &amp;&amp; ek != reflect.Array &amp;&amp; ek != reflect.String </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var e, a string

        switch et </span>{
        case reflect.TypeOf(""):<span class="cov8" title="1">
                e = reflect.ValueOf(expected).String()
                a = reflect.ValueOf(actual).String()</span>
        case reflect.TypeOf(time.Time{}):<span class="cov8" title="1">
                e = spewConfigStringerEnabled.Sdump(expected)
                a = spewConfigStringerEnabled.Sdump(actual)</span>
        default:<span class="cov8" title="1">
                e = spewConfig.Sdump(expected)
                a = spewConfig.Sdump(actual)</span>
        }

        <span class="cov8" title="1">diff, _ := difflib.GetUnifiedDiffString(difflib.UnifiedDiff{
                A:        difflib.SplitLines(e),
                B:        difflib.SplitLines(a),
                FromFile: "Expected",
                FromDate: "",
                ToFile:   "Actual",
                ToDate:   "",
                Context:  1,
        })

        return "\n\nDiff:\n" + diff</span>
}

func isFunction(arg interface{}) bool <span class="cov8" title="1">{
        if arg == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return reflect.TypeOf(arg).Kind() == reflect.Func</span>
}

var spewConfig = spew.ConfigState{
        Indent:                  " ",
        DisablePointerAddresses: true,
        DisableCapacities:       true,
        SortKeys:                true,
        DisableMethods:          true,
        MaxDepth:                10,
}

var spewConfigStringerEnabled = spew.ConfigState{
        Indent:                  " ",
        DisablePointerAddresses: true,
        DisableCapacities:       true,
        SortKeys:                true,
        MaxDepth:                10,
}

type tHelper = interface {
        Helper()
}

// Eventually asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        assert.Eventually(t, func() bool { return true; }, time.Second, 10*time.Millisecond)
func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">ch := make(chan bool, 1)

        timer := time.NewTimer(waitFor)
        defer timer.Stop()

        ticker := time.NewTicker(tick)
        defer ticker.Stop()

        for tick := ticker.C; ; </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timer.C:<span class="cov8" title="1">
                        return Fail(t, "Condition never satisfied", msgAndArgs...)</span>
                case &lt;-tick:<span class="cov8" title="1">
                        tick = nil
                        go func() </span><span class="cov8" title="1">{ ch &lt;- condition() }</span>()
                case v := &lt;-ch:<span class="cov8" title="1">
                        if v </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">tick = ticker.C</span>
                }
        }
}

// CollectT implements the TestingT interface and collects all errors.
type CollectT struct {
        // A slice of errors. Non-nil slice denotes a failure.
        // If it's non-nil but len(c.errors) == 0, this is also a failure
        // obtained by direct c.FailNow() call.
        errors []error
}

// Errorf collects the error.
func (c *CollectT) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        c.errors = append(c.errors, fmt.Errorf(format, args...))
}</span>

// FailNow stops execution by calling runtime.Goexit.
func (c *CollectT) FailNow() <span class="cov8" title="1">{
        c.fail()
        runtime.Goexit()
}</span>

// Deprecated: That was a method for internal usage that should not have been published. Now just panics.
func (*CollectT) Reset() <span class="cov0" title="0">{
        panic("Reset() is deprecated")</span>
}

// Deprecated: That was a method for internal usage that should not have been published. Now just panics.
func (*CollectT) Copy(TestingT) <span class="cov0" title="0">{
        panic("Copy() is deprecated")</span>
}

func (c *CollectT) fail() <span class="cov8" title="1">{
        if !c.failed() </span><span class="cov8" title="1">{
                c.errors = []error{} // Make it non-nil to mark a failure.
        }</span>
}

func (c *CollectT) failed() bool <span class="cov8" title="1">{
        return c.errors != nil
}</span>

// EventuallyWithT asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        assert.EventuallyWithT(t, func(c *assert.CollectT) {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func EventuallyWithT(t TestingT, condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">var lastFinishedTickErrs []error
        ch := make(chan *CollectT, 1)

        timer := time.NewTimer(waitFor)
        defer timer.Stop()

        ticker := time.NewTicker(tick)
        defer ticker.Stop()

        for tick := ticker.C; ; </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timer.C:<span class="cov8" title="1">
                        for _, err := range lastFinishedTickErrs </span><span class="cov8" title="1">{
                                t.Errorf("%v", err)
                        }</span>
                        <span class="cov8" title="1">return Fail(t, "Condition never satisfied", msgAndArgs...)</span>
                case &lt;-tick:<span class="cov8" title="1">
                        tick = nil
                        go func() </span><span class="cov8" title="1">{
                                collect := new(CollectT)
                                defer func() </span><span class="cov8" title="1">{
                                        ch &lt;- collect
                                }</span>()
                                <span class="cov8" title="1">condition(collect)</span>
                        }()
                case collect := &lt;-ch:<span class="cov8" title="1">
                        if !collect.failed() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        // Keep the errors from the last ended condition, so that they can be copied to t if timeout is reached.
                        <span class="cov8" title="1">lastFinishedTickErrs = collect.errors
                        tick = ticker.C</span>
                }
        }
}

// Never asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        assert.Never(t, func() bool { return false; }, time.Second, 10*time.Millisecond)
func Never(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">ch := make(chan bool, 1)

        timer := time.NewTimer(waitFor)
        defer timer.Stop()

        ticker := time.NewTicker(tick)
        defer ticker.Stop()

        for tick := ticker.C; ; </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timer.C:<span class="cov8" title="1">
                        return true</span>
                case &lt;-tick:<span class="cov8" title="1">
                        tick = nil
                        go func() </span><span class="cov8" title="1">{ ch &lt;- condition() }</span>()
                case v := &lt;-ch:<span class="cov8" title="1">
                        if v </span><span class="cov8" title="1">{
                                return Fail(t, "Condition satisfied", msgAndArgs...)
                        }</span>
                        <span class="cov8" title="1">tick = ticker.C</span>
                }
        }
}

// ErrorIs asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func ErrorIs(t TestingT, err, target error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if errors.Is(err, target) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">var expectedText string
        if target != nil </span><span class="cov8" title="1">{
                expectedText = target.Error()
        }</span>

        <span class="cov8" title="1">chain := buildErrorChainString(err)

        return Fail(t, fmt.Sprintf("Target error should be in err chain:\n"+
                "expected: %q\n"+
                "in chain: %s", expectedText, chain,
        ), msgAndArgs...)</span>
}

// NotErrorIs asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func NotErrorIs(t TestingT, err, target error, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if !errors.Is(err, target) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">var expectedText string
        if target != nil </span><span class="cov8" title="1">{
                expectedText = target.Error()
        }</span>

        <span class="cov8" title="1">chain := buildErrorChainString(err)

        return Fail(t, fmt.Sprintf("Target error should not be in err chain:\n"+
                "found: %q\n"+
                "in chain: %s", expectedText, chain,
        ), msgAndArgs...)</span>
}

// ErrorAs asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func ErrorAs(t TestingT, err error, target interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if errors.As(err, target) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">chain := buildErrorChainString(err)

        return Fail(t, fmt.Sprintf("Should be in error chain:\n"+
                "expected: %q\n"+
                "in chain: %s", target, chain,
        ), msgAndArgs...)</span>
}

// NotErrorAs asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func NotErrorAs(t TestingT, err error, target interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if !errors.As(err, target) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">chain := buildErrorChainString(err)

        return Fail(t, fmt.Sprintf("Target error should not be in err chain:\n"+
                "found: %q\n"+
                "in chain: %s", target, chain,
        ), msgAndArgs...)</span>
}

func buildErrorChainString(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">e := errors.Unwrap(err)
        chain := fmt.Sprintf("%q", err.Error())
        for e != nil </span><span class="cov8" title="1">{
                chain += fmt.Sprintf("\n\t%q", e.Error())
                e = errors.Unwrap(e)
        }</span>
        <span class="cov8" title="1">return chain</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package assert

// Assertions provides assertion methods around the
// TestingT interface.
type Assertions struct {
        t TestingT
}

// New makes a new Assertions object for the specified TestingT.
func New(t TestingT) *Assertions <span class="cov8" title="1">{
        return &amp;Assertions{
                t: t,
        }
}</span>

//go:generate sh -c "cd ../_codegen &amp;&amp; go build &amp;&amp; cd - &amp;&amp; ../_codegen/_codegen -output-package=assert -template=assertion_forward.go.tmpl -include-format-funcs"
</pre>
		
		<pre class="file" id="file6" style="display: none">package assert

import (
        "fmt"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"
)

// httpCode is a helper that returns HTTP code of the response. It returns -1 and
// an error if building a new request fails.
func httpCode(handler http.HandlerFunc, method, url string, values url.Values) (int, error) <span class="cov8" title="1">{
        w := httptest.NewRecorder()
        req, err := http.NewRequest(method, url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">req.URL.RawQuery = values.Encode()
        handler(w, req)
        return w.Code, nil</span>
}

// HTTPSuccess asserts that a specified handler returns a success status code.
//
//        assert.HTTPSuccess(t, myHandler, "POST", "http://www.google.com", nil)
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPSuccess(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">code, err := httpCode(handler, method, url, values)
        if err != nil </span><span class="cov0" title="0">{
                Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">isSuccessCode := code &gt;= http.StatusOK &amp;&amp; code &lt;= http.StatusPartialContent
        if !isSuccessCode </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected HTTP success status code for %q but received %d", url+"?"+values.Encode(), code), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return isSuccessCode</span>
}

// HTTPRedirect asserts that a specified handler returns a redirect status code.
//
//        assert.HTTPRedirect(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPRedirect(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">code, err := httpCode(handler, method, url, values)
        if err != nil </span><span class="cov0" title="0">{
                Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">isRedirectCode := code &gt;= http.StatusMultipleChoices &amp;&amp; code &lt;= http.StatusTemporaryRedirect
        if !isRedirectCode </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected HTTP redirect status code for %q but received %d", url+"?"+values.Encode(), code), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return isRedirectCode</span>
}

// HTTPError asserts that a specified handler returns an error status code.
//
//        assert.HTTPError(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPError(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">code, err := httpCode(handler, method, url, values)
        if err != nil </span><span class="cov0" title="0">{
                Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">isErrorCode := code &gt;= http.StatusBadRequest
        if !isErrorCode </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected HTTP error status code for %q but received %d", url+"?"+values.Encode(), code), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return isErrorCode</span>
}

// HTTPStatusCode asserts that a specified handler returns a specified status code.
//
//        assert.HTTPStatusCode(t, myHandler, "GET", "/notImplemented", nil, 501)
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPStatusCode(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, statuscode int, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">code, err := httpCode(handler, method, url, values)
        if err != nil </span><span class="cov0" title="0">{
                Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">successful := code == statuscode
        if !successful </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected HTTP status code %d for %q but received %d", statuscode, url+"?"+values.Encode(), code), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return successful</span>
}

// HTTPBody is a helper that returns HTTP body of the response. It returns
// empty string if building a new request fails.
func HTTPBody(handler http.HandlerFunc, method, url string, values url.Values) string <span class="cov8" title="1">{
        w := httptest.NewRecorder()
        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                url += "?" + values.Encode()
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest(method, url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">handler(w, req)
        return w.Body.String()</span>
}

// HTTPBodyContains asserts that a specified handler returns a
// body that contains a string.
//
//        assert.HTTPBodyContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">body := HTTPBody(handler, method, url, values)

        contains := strings.Contains(body, fmt.Sprint(str))
        if !contains </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected response body for \"%s\" to contain \"%s\" but found \"%s\"", url+"?"+values.Encode(), str, body), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return contains</span>
}

// HTTPBodyNotContains asserts that a specified handler returns a
// body that does not contain a string.
//
//        assert.HTTPBodyNotContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyNotContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">body := HTTPBody(handler, method, url, values)

        contains := strings.Contains(body, fmt.Sprint(str))
        if contains </span><span class="cov8" title="1">{
                Fail(t, fmt.Sprintf("Expected response body for \"%s\" to NOT contain \"%s\" but found \"%s\"", url+"?"+values.Encode(), str, body), msgAndArgs...)
        }</span>

        <span class="cov8" title="1">return !contains</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//go:build !testify_yaml_fail &amp;&amp; !testify_yaml_custom
// +build !testify_yaml_fail,!testify_yaml_custom

// Package yaml is just an indirection to handle YAML deserialization.
//
// This package is just an indirection that allows the builder to override the
// indirection with an alternative implementation of this package that uses
// another implementation of YAML deserialization. This allows to not either not
// use YAML deserialization at all, or to use another implementation than
// [gopkg.in/yaml.v3] (for example for license compatibility reasons, see [PR #1120]).
//
// Alternative implementations are selected using build tags:
//
//   - testify_yaml_fail: [Unmarshal] always fails with an error
//   - testify_yaml_custom: [Unmarshal] is a variable. Caller must initialize it
//     before calling any of [github.com/stretchr/testify/assert.YAMLEq] or
//     [github.com/stretchr/testify/assert.YAMLEqf].
//
// Usage:
//
//        go test -tags testify_yaml_fail
//
// You can check with "go list" which implementation is linked:
//
//        go list -f '{{.Imports}}' github.com/stretchr/testify/assert/yaml
//        go list -tags testify_yaml_fail -f '{{.Imports}}' github.com/stretchr/testify/assert/yaml
//        go list -tags testify_yaml_custom -f '{{.Imports}}' github.com/stretchr/testify/assert/yaml
//
// [PR #1120]: https://github.com/stretchr/testify/pull/1120
package yaml

import goyaml "gopkg.in/yaml.v3"

// Unmarshal is just a wrapper of [gopkg.in/yaml.v3.Unmarshal].
func Unmarshal(in []byte, out interface{}) error <span class="cov8" title="1">{
        return goyaml.Unmarshal(in, out)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package http

import (
        "net/http"
)

// Deprecated: Use [net/http/httptest] instead.
type TestResponseWriter struct {

        // StatusCode is the last int written by the call to WriteHeader(int)
        StatusCode int

        // Output is a string containing the written bytes using the Write([]byte) func.
        Output string

        // header is the internal storage of the http.Header object
        header http.Header
}

// Deprecated: Use [net/http/httptest] instead.
func (rw *TestResponseWriter) Header() http.Header <span class="cov0" title="0">{

        if rw.header == nil </span><span class="cov0" title="0">{
                rw.header = make(http.Header)
        }</span>

        <span class="cov0" title="0">return rw.header</span>
}

// Deprecated: Use [net/http/httptest] instead.
func (rw *TestResponseWriter) Write(bytes []byte) (int, error) <span class="cov0" title="0">{

        // assume 200 success if no header has been set
        if rw.StatusCode == 0 </span><span class="cov0" title="0">{
                rw.WriteHeader(200)
        }</span>

        // add these bytes to the output string
        <span class="cov0" title="0">rw.Output += string(bytes)

        // return normal values
        return 0, nil</span>

}

// Deprecated: Use [net/http/httptest] instead.
func (rw *TestResponseWriter) WriteHeader(i int) <span class="cov0" title="0">{
        rw.StatusCode = i
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "net/http"

        "github.com/stretchr/testify/mock"
)

// Deprecated: Use [net/http/httptest] instead.
type TestRoundTripper struct {
        mock.Mock
}

// Deprecated: Use [net/http/httptest] instead.
func (t *TestRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        args := t.Called(req)
        return args.Get(0).(*http.Response), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "errors"
        "fmt"
        "path"
        "reflect"
        "regexp"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/davecgh/go-spew/spew"
        "github.com/pmezard/go-difflib/difflib"
        "github.com/stretchr/objx"

        "github.com/stretchr/testify/assert"
)

// regex for GCCGO functions
var gccgoRE = regexp.MustCompile(`\.pN\d+_`)

// TestingT is an interface wrapper around *testing.T
type TestingT interface {
        Logf(format string, args ...interface{})
        Errorf(format string, args ...interface{})
        FailNow()
}

/*
        Call
*/

// Call represents a method call and is used for setting expectations,
// as well as recording activity.
type Call struct {
        Parent *Mock

        // The name of the method that was or will be called.
        Method string

        // Holds the arguments of the method.
        Arguments Arguments

        // Holds the arguments that should be returned when
        // this method is called.
        ReturnArguments Arguments

        // Holds the caller info for the On() call
        callerInfo []string

        // The number of times to return the return arguments when setting
        // expectations. 0 means to always return the value.
        Repeatability int

        // Amount of times this call has been called
        totalCalls int

        // Call to this method can be optional
        optional bool

        // Holds a channel that will be used to block the Return until it either
        // receives a message or is closed. nil means it returns immediately.
        WaitFor &lt;-chan time.Time

        waitTime time.Duration

        // Holds a handler used to manipulate arguments content that are passed by
        // reference. It's useful when mocking methods such as unmarshalers or
        // decoders.
        RunFn func(Arguments)

        // PanicMsg holds msg to be used to mock panic on the function call
        //  if the PanicMsg is set to a non nil string the function call will panic
        // irrespective of other settings
        PanicMsg *string

        // Calls which must be satisfied before this call can be
        requires []*Call
}

func newCall(parent *Mock, methodName string, callerInfo []string, methodArguments Arguments, returnArguments Arguments) *Call <span class="cov8" title="1">{
        return &amp;Call{
                Parent:          parent,
                Method:          methodName,
                Arguments:       methodArguments,
                ReturnArguments: returnArguments,
                callerInfo:      callerInfo,
                Repeatability:   0,
                WaitFor:         nil,
                RunFn:           nil,
                PanicMsg:        nil,
        }
}</span>

func (c *Call) lock() <span class="cov8" title="1">{
        c.Parent.mutex.Lock()
}</span>

func (c *Call) unlock() <span class="cov8" title="1">{
        c.Parent.mutex.Unlock()
}</span>

// Return specifies the return arguments for the expectation.
//
//        Mock.On("DoSomething").Return(errors.New("failed"))
func (c *Call) Return(returnArguments ...interface{}) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()

        c.ReturnArguments = returnArguments

        return c
}</span>

// Panic specifies if the function call should fail and the panic message
//
//        Mock.On("DoSomething").Panic("test panic")
func (c *Call) Panic(msg string) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()

        c.PanicMsg = &amp;msg

        return c
}</span>

// Once indicates that the mock should only return the value once.
//
//        Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Once()
func (c *Call) Once() *Call <span class="cov8" title="1">{
        return c.Times(1)
}</span>

// Twice indicates that the mock should only return the value twice.
//
//        Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Twice()
func (c *Call) Twice() *Call <span class="cov8" title="1">{
        return c.Times(2)
}</span>

// Times indicates that the mock should only return the indicated number
// of times.
//
//        Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Times(5)
func (c *Call) Times(i int) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()
        c.Repeatability = i
        return c
}</span>

// WaitUntil sets the channel that will block the mock's return until its closed
// or a message is received.
//
//        Mock.On("MyMethod", arg1, arg2).WaitUntil(time.After(time.Second))
func (c *Call) WaitUntil(w &lt;-chan time.Time) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()
        c.WaitFor = w
        return c
}</span>

// After sets how long to block until the call returns
//
//        Mock.On("MyMethod", arg1, arg2).After(time.Second)
func (c *Call) After(d time.Duration) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()
        c.waitTime = d
        return c
}</span>

// Run sets a handler to be called before returning. It can be used when
// mocking a method (such as an unmarshaler) that takes a pointer to a struct and
// sets properties in such struct
//
//        Mock.On("Unmarshal", AnythingOfType("*map[string]interface{}")).Return().Run(func(args Arguments) {
//                arg := args.Get(0).(*map[string]interface{})
//                arg["foo"] = "bar"
//        })
func (c *Call) Run(fn func(args Arguments)) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()
        c.RunFn = fn
        return c
}</span>

// Maybe allows the method call to be optional. Not calling an optional method
// will not cause an error while asserting expectations
func (c *Call) Maybe() *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()
        c.optional = true
        return c
}</span>

// On chains a new expectation description onto the mocked interface. This
// allows syntax like.
//
//        Mock.
//           On("MyMethod", 1).Return(nil).
//           On("MyOtherMethod", 'a', 'b', 'c').Return(errors.New("Some Error"))
//
//go:noinline
func (c *Call) On(methodName string, arguments ...interface{}) *Call <span class="cov8" title="1">{
        return c.Parent.On(methodName, arguments...)
}</span>

// Unset removes a mock handler from being called.
//
//        test.On("func", mock.Anything).Unset()
func (c *Call) Unset() *Call <span class="cov8" title="1">{
        var unlockOnce sync.Once

        for _, arg := range c.Arguments </span><span class="cov8" title="1">{
                if v := reflect.ValueOf(arg); v.Kind() == reflect.Func </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("cannot use Func in expectations. Use mock.AnythingOfType(\"%T\")", arg))</span>
                }
        }

        <span class="cov8" title="1">c.lock()
        defer unlockOnce.Do(c.unlock)

        foundMatchingCall := false

        // in-place filter slice for calls to be removed - iterate from 0'th to last skipping unnecessary ones
        var index int // write index
        for _, call := range c.Parent.ExpectedCalls </span><span class="cov8" title="1">{
                if call.Method == c.Method </span><span class="cov8" title="1">{
                        _, diffCount := call.Arguments.Diff(c.Arguments)
                        if diffCount == 0 </span><span class="cov8" title="1">{
                                foundMatchingCall = true
                                // Remove from ExpectedCalls - just skip it
                                continue</span>
                        }
                }
                <span class="cov8" title="1">c.Parent.ExpectedCalls[index] = call
                index++</span>
        }
        // trim slice up to last copied index
        <span class="cov8" title="1">c.Parent.ExpectedCalls = c.Parent.ExpectedCalls[:index]

        if !foundMatchingCall </span><span class="cov8" title="1">{
                unlockOnce.Do(c.unlock)
                c.Parent.fail("\n\nmock: Could not find expected call\n-----------------------------\n\n%s\n\n",
                        callString(c.Method, c.Arguments, true),
                )
        }</span>

        <span class="cov8" title="1">return c</span>
}

// NotBefore indicates that the mock should only be called after the referenced
// calls have been called as expected. The referenced calls may be from the
// same mock instance and/or other mock instances.
//
//        Mock.On("Do").Return(nil).NotBefore(
//            Mock.On("Init").Return(nil)
//        )
func (c *Call) NotBefore(calls ...*Call) *Call <span class="cov8" title="1">{
        c.lock()
        defer c.unlock()

        for _, call := range calls </span><span class="cov8" title="1">{
                if call.Parent == nil </span><span class="cov8" title="1">{
                        panic("not before calls must be created with Mock.On()")</span>
                }
        }

        <span class="cov8" title="1">c.requires = append(c.requires, calls...)
        return c</span>
}

// InOrder defines the order in which the calls should be made
//
//        For example:
//
//        InOrder(
//                Mock.On("init").Return(nil),
//                Mock.On("Do").Return(nil),
//        )
func InOrder(calls ...*Call) <span class="cov8" title="1">{
        for i := 1; i &lt; len(calls); i++ </span><span class="cov8" title="1">{
                calls[i].NotBefore(calls[i-1])
        }</span>
}

// Mock is the workhorse used to track activity on another object.
// For an example of its usage, refer to the "Example Usage" section at the top
// of this document.
type Mock struct {
        // Represents the calls that are expected of
        // an object.
        ExpectedCalls []*Call

        // Holds the calls that were made to this mocked object.
        Calls []Call

        // test is An optional variable that holds the test struct, to be used when an
        // invalid mock call was made.
        test TestingT

        // TestData holds any data that might be useful for testing.  Testify ignores
        // this data completely allowing you to do whatever you like with it.
        testData objx.Map

        mutex sync.Mutex
}

// String provides a %v format string for Mock.
// Note: this is used implicitly by Arguments.Diff if a Mock is passed.
// It exists because go's default %v formatting traverses the struct
// without acquiring the mutex, which is detected by go test -race.
func (m *Mock) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%[1]T&lt;%[1]p&gt;", m)
}</span>

// TestData holds any data that might be useful for testing.  Testify ignores
// this data completely allowing you to do whatever you like with it.
func (m *Mock) TestData() objx.Map <span class="cov8" title="1">{
        if m.testData == nil </span><span class="cov8" title="1">{
                m.testData = make(objx.Map)
        }</span>

        <span class="cov8" title="1">return m.testData</span>
}

/*
        Setting expectations
*/

// Test sets the test struct variable of the mock object
func (m *Mock) Test(t TestingT) <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.test = t
}</span>

// fail fails the current test with the given formatted format and args.
// In case that a test was defined, it uses the test APIs for failing a test,
// otherwise it uses panic.
func (m *Mock) fail(format string, args ...interface{}) <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.test == nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf(format, args...))</span>
        }
        <span class="cov8" title="1">m.test.Errorf(format, args...)
        m.test.FailNow()</span>
}

// On starts a description of an expectation of the specified method
// being called.
//
//        Mock.On("MyMethod", arg1, arg2)
func (m *Mock) On(methodName string, arguments ...interface{}) *Call <span class="cov8" title="1">{
        for _, arg := range arguments </span><span class="cov8" title="1">{
                if v := reflect.ValueOf(arg); v.Kind() == reflect.Func </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("cannot use Func in expectations. Use mock.AnythingOfType(\"%T\")", arg))</span>
                }
        }

        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()

        c := newCall(m, methodName, assert.CallerInfo(), arguments, make([]interface{}, 0))
        m.ExpectedCalls = append(m.ExpectedCalls, c)
        return c</span>
}

// /*
//         Recording and responding to activity
// */

func (m *Mock) findExpectedCall(method string, arguments ...interface{}) (int, *Call) <span class="cov8" title="1">{
        var expectedCall *Call

        for i, call := range m.ExpectedCalls </span><span class="cov8" title="1">{
                if call.Method == method </span><span class="cov8" title="1">{
                        _, diffCount := call.Arguments.Diff(arguments)
                        if diffCount == 0 </span><span class="cov8" title="1">{
                                expectedCall = call
                                if call.Repeatability &gt; -1 </span><span class="cov8" title="1">{
                                        return i, call
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return -1, expectedCall</span>
}

type matchCandidate struct {
        call      *Call
        mismatch  string
        diffCount int
}

func (c matchCandidate) isBetterMatchThan(other matchCandidate) bool <span class="cov8" title="1">{
        if c.call == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if other.call == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if c.diffCount &gt; other.diffCount </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if c.diffCount &lt; other.diffCount </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if c.call.Repeatability &gt; 0 &amp;&amp; other.call.Repeatability &lt;= 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (m *Mock) findClosestCall(method string, arguments ...interface{}) (*Call, string) <span class="cov8" title="1">{
        var bestMatch matchCandidate

        for _, call := range m.expectedCalls() </span><span class="cov8" title="1">{
                if call.Method == method </span><span class="cov8" title="1">{

                        errInfo, tempDiffCount := call.Arguments.Diff(arguments)
                        tempCandidate := matchCandidate{
                                call:      call,
                                mismatch:  errInfo,
                                diffCount: tempDiffCount,
                        }
                        if tempCandidate.isBetterMatchThan(bestMatch) </span><span class="cov8" title="1">{
                                bestMatch = tempCandidate
                        }</span>
                }
        }

        <span class="cov8" title="1">return bestMatch.call, bestMatch.mismatch</span>
}

func callString(method string, arguments Arguments, includeArgumentValues bool) string <span class="cov8" title="1">{
        var argValsString string
        if includeArgumentValues </span><span class="cov8" title="1">{
                var argVals []string
                for argIndex, arg := range arguments </span><span class="cov8" title="1">{
                        if _, ok := arg.(*FunctionalOptionsArgument); ok </span><span class="cov8" title="1">{
                                argVals = append(argVals, fmt.Sprintf("%d: %s", argIndex, arg))
                                continue</span>
                        }
                        <span class="cov8" title="1">argVals = append(argVals, fmt.Sprintf("%d: %#v", argIndex, arg))</span>
                }
                <span class="cov8" title="1">argValsString = fmt.Sprintf("\n\t\t%s", strings.Join(argVals, "\n\t\t"))</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("%s(%s)%s", method, arguments.String(), argValsString)</span>
}

// Called tells the mock object that a method has been called, and gets an array
// of arguments to return.  Panics if the call is unexpected (i.e. not preceded by
// appropriate .On .Return() calls)
// If Call.WaitFor is set, blocks until the channel is closed or receives a message.
func (m *Mock) Called(arguments ...interface{}) Arguments <span class="cov8" title="1">{
        // get the calling function's name
        pc, _, _, ok := runtime.Caller(1)
        if !ok </span><span class="cov0" title="0">{
                panic("Couldn't get the caller information")</span>
        }
        <span class="cov8" title="1">functionPath := runtime.FuncForPC(pc).Name()
        // Next four lines are required to use GCCGO function naming conventions.
        // For Ex:  github_com_docker_libkv_store_mock.WatchTree.pN39_github_com_docker_libkv_store_mock.Mock
        // uses interface information unlike golang github.com/docker/libkv/store/mock.(*Mock).WatchTree
        // With GCCGO we need to remove interface information starting from pN&lt;dd&gt;.
        if gccgoRE.MatchString(functionPath) </span><span class="cov0" title="0">{
                functionPath = gccgoRE.Split(functionPath, -1)[0]
        }</span>
        <span class="cov8" title="1">parts := strings.Split(functionPath, ".")
        functionName := parts[len(parts)-1]
        return m.MethodCalled(functionName, arguments...)</span>
}

// MethodCalled tells the mock object that the given method has been called, and gets
// an array of arguments to return. Panics if the call is unexpected (i.e. not preceded
// by appropriate .On .Return() calls)
// If Call.WaitFor is set, blocks until the channel is closed or receives a message.
func (m *Mock) MethodCalled(methodName string, arguments ...interface{}) Arguments <span class="cov8" title="1">{
        m.mutex.Lock()
        // TODO: could combine expected and closes in single loop
        found, call := m.findExpectedCall(methodName, arguments...)

        if found &lt; 0 </span><span class="cov8" title="1">{
                // expected call found, but it has already been called with repeatable times
                if call != nil </span><span class="cov8" title="1">{
                        m.mutex.Unlock()
                        m.fail("\nassert: mock: The method has been called over %d times.\n\tEither do one more Mock.On(\"%s\").Return(...), or remove extra call.\n\tThis call was unexpected:\n\t\t%s\n\tat: %s", call.totalCalls, methodName, callString(methodName, arguments, true), assert.CallerInfo())
                }</span>
                // we have to fail here - because we don't know what to do
                // as the return arguments.  This is because:
                //
                //   a) this is a totally unexpected call to this method,
                //   b) the arguments are not what was expected, or
                //   c) the developer has forgotten to add an accompanying On...Return pair.
                <span class="cov8" title="1">closestCall, mismatch := m.findClosestCall(methodName, arguments...)
                m.mutex.Unlock()

                if closestCall != nil </span><span class="cov8" title="1">{
                        m.fail("\n\nmock: Unexpected Method Call\n-----------------------------\n\n%s\n\nThe closest call I have is: \n\n%s\n\n%s\nDiff: %s\nat: %s\n",
                                callString(methodName, arguments, true),
                                callString(methodName, closestCall.Arguments, true),
                                diffArguments(closestCall.Arguments, arguments),
                                strings.TrimSpace(mismatch),
                                assert.CallerInfo(),
                        )
                }</span> else<span class="cov8" title="1"> {
                        m.fail("\nassert: mock: I don't know what to return because the method call was unexpected.\n\tEither do Mock.On(\"%s\").Return(...) first, or remove the %s() call.\n\tThis method was unexpected:\n\t\t%s\n\tat: %s", methodName, methodName, callString(methodName, arguments, true), assert.CallerInfo())
                }</span>
        }

        <span class="cov8" title="1">for _, requirement := range call.requires </span><span class="cov8" title="1">{
                if satisfied, _ := requirement.Parent.checkExpectation(requirement); !satisfied </span><span class="cov8" title="1">{
                        m.mutex.Unlock()
                        m.fail("mock: Unexpected Method Call\n-----------------------------\n\n%s\n\nMust not be called before%s:\n\n%s",
                                callString(call.Method, call.Arguments, true),
                                func() (s string) </span><span class="cov8" title="1">{
                                        if requirement.totalCalls &gt; 0 </span><span class="cov8" title="1">{
                                                s = " another call of"
                                        }</span>
                                        <span class="cov8" title="1">if call.Parent != requirement.Parent </span><span class="cov8" title="1">{
                                                s += " method from another mock instance"
                                        }</span>
                                        <span class="cov8" title="1">return</span>
                                }(),
                                callString(requirement.Method, requirement.Arguments, true),
                        )
                }
        }

        <span class="cov8" title="1">if call.Repeatability == 1 </span><span class="cov8" title="1">{
                call.Repeatability = -1
        }</span> else<span class="cov8" title="1"> if call.Repeatability &gt; 1 </span><span class="cov8" title="1">{
                call.Repeatability--
        }</span>
        <span class="cov8" title="1">call.totalCalls++

        // add the call
        m.Calls = append(m.Calls, *newCall(m, methodName, assert.CallerInfo(), arguments, call.ReturnArguments))
        m.mutex.Unlock()

        // block if specified
        if call.WaitFor != nil </span><span class="cov8" title="1">{
                &lt;-call.WaitFor
        }</span> else<span class="cov8" title="1"> {
                time.Sleep(call.waitTime)
        }</span>

        <span class="cov8" title="1">m.mutex.Lock()
        panicMsg := call.PanicMsg
        m.mutex.Unlock()
        if panicMsg != nil </span><span class="cov8" title="1">{
                panic(*panicMsg)</span>
        }

        <span class="cov8" title="1">m.mutex.Lock()
        runFn := call.RunFn
        m.mutex.Unlock()

        if runFn != nil </span><span class="cov8" title="1">{
                runFn(arguments)
        }</span>

        <span class="cov8" title="1">m.mutex.Lock()
        returnArgs := call.ReturnArguments
        m.mutex.Unlock()

        return returnArgs</span>
}

/*
        Assertions
*/

type assertExpectationiser interface {
        AssertExpectations(TestingT) bool
}

// AssertExpectationsForObjects asserts that everything specified with On and Return
// of the specified objects was in fact called as expected.
//
// Calls may have occurred in any order.
func AssertExpectationsForObjects(t TestingT, testObjects ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">for _, obj := range testObjects </span><span class="cov8" title="1">{
                if m, ok := obj.(*Mock); ok </span><span class="cov8" title="1">{
                        t.Logf("Deprecated mock.AssertExpectationsForObjects(myMock.Mock) use mock.AssertExpectationsForObjects(myMock)")
                        obj = m
                }</span>
                <span class="cov8" title="1">m := obj.(assertExpectationiser)
                if !m.AssertExpectations(t) </span><span class="cov8" title="1">{
                        t.Logf("Expectations didn't match for Mock: %+v", reflect.TypeOf(m))
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AssertExpectations asserts that everything specified with On and Return was
// in fact called as expected.  Calls may have occurred in any order.
func (m *Mock) AssertExpectations(t TestingT) bool <span class="cov8" title="1">{
        if s, ok := t.(interface{ Skipped() bool }); ok &amp;&amp; s.Skipped() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()
        var failedExpectations int

        // iterate through each expectation
        expectedCalls := m.expectedCalls()
        for _, expectedCall := range expectedCalls </span><span class="cov8" title="1">{
                satisfied, reason := m.checkExpectation(expectedCall)
                if !satisfied </span><span class="cov8" title="1">{
                        failedExpectations++
                        t.Logf(reason)
                }</span>
        }

        <span class="cov8" title="1">if failedExpectations != 0 </span><span class="cov8" title="1">{
                t.Errorf("FAIL: %d out of %d expectation(s) were met.\n\tThe code you are testing needs to make %d more call(s).\n\tat: %s", len(expectedCalls)-failedExpectations, len(expectedCalls), failedExpectations, assert.CallerInfo())
        }</span>

        <span class="cov8" title="1">return failedExpectations == 0</span>
}

func (m *Mock) checkExpectation(call *Call) (bool, string) <span class="cov8" title="1">{
        if !call.optional &amp;&amp; !m.methodWasCalled(call.Method, call.Arguments) &amp;&amp; call.totalCalls == 0 </span><span class="cov8" title="1">{
                return false, fmt.Sprintf("FAIL:\t%s(%s)\n\t\tat: %s", call.Method, call.Arguments.String(), call.callerInfo)
        }</span>
        <span class="cov8" title="1">if call.Repeatability &gt; 0 </span><span class="cov8" title="1">{
                return false, fmt.Sprintf("FAIL:\t%s(%s)\n\t\tat: %s", call.Method, call.Arguments.String(), call.callerInfo)
        }</span>
        <span class="cov8" title="1">return true, fmt.Sprintf("PASS:\t%s(%s)", call.Method, call.Arguments.String())</span>
}

// AssertNumberOfCalls asserts that the method was called expectedCalls times.
func (m *Mock) AssertNumberOfCalls(t TestingT, methodName string, expectedCalls int) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()
        var actualCalls int
        for _, call := range m.calls() </span><span class="cov8" title="1">{
                if call.Method == methodName </span><span class="cov8" title="1">{
                        actualCalls++
                }</span>
        }
        <span class="cov8" title="1">return assert.Equal(t, expectedCalls, actualCalls, fmt.Sprintf("Expected number of calls (%d) does not match the actual number of calls (%d).", expectedCalls, actualCalls))</span>
}

// AssertCalled asserts that the method was called.
// It can produce a false result when an argument is a pointer type and the underlying value changed after calling the mocked method.
func (m *Mock) AssertCalled(t TestingT, methodName string, arguments ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()
        if !m.methodWasCalled(methodName, arguments) </span><span class="cov8" title="1">{
                var calledWithArgs []string
                for _, call := range m.calls() </span><span class="cov8" title="1">{
                        calledWithArgs = append(calledWithArgs, fmt.Sprintf("%v", call.Arguments))
                }</span>
                <span class="cov8" title="1">if len(calledWithArgs) == 0 </span><span class="cov0" title="0">{
                        return assert.Fail(t, "Should have called with given arguments",
                                fmt.Sprintf("Expected %q to have been called with:\n%v\nbut no actual calls happened", methodName, arguments))
                }</span>
                <span class="cov8" title="1">return assert.Fail(t, "Should have called with given arguments",
                        fmt.Sprintf("Expected %q to have been called with:\n%v\nbut actual calls were:\n        %v", methodName, arguments, strings.Join(calledWithArgs, "\n")))</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AssertNotCalled asserts that the method was not called.
// It can produce a false result when an argument is a pointer type and the underlying value changed after calling the mocked method.
func (m *Mock) AssertNotCalled(t TestingT, methodName string, arguments ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()
        if m.methodWasCalled(methodName, arguments) </span><span class="cov0" title="0">{
                return assert.Fail(t, "Should not have called with given arguments",
                        fmt.Sprintf("Expected %q to not have been called with:\n%v\nbut actually it was.", methodName, arguments))
        }</span>
        <span class="cov8" title="1">return true</span>
}

// IsMethodCallable checking that the method can be called
// If the method was called more than `Repeatability` return false
func (m *Mock) IsMethodCallable(t TestingT, methodName string, arguments ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">m.mutex.Lock()
        defer m.mutex.Unlock()

        for _, v := range m.ExpectedCalls </span><span class="cov8" title="1">{
                if v.Method != methodName </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(arguments) != len(v.Arguments) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if v.Repeatability &lt; v.totalCalls </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if isArgsEqual(v.Arguments, arguments) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isArgsEqual compares arguments
func isArgsEqual(expected Arguments, args []interface{}) bool <span class="cov8" title="1">{
        if len(expected) != len(args) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range args </span><span class="cov8" title="1">{
                if !reflect.DeepEqual(expected[i], v) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *Mock) methodWasCalled(methodName string, expected []interface{}) bool <span class="cov8" title="1">{
        for _, call := range m.calls() </span><span class="cov8" title="1">{
                if call.Method == methodName </span><span class="cov8" title="1">{

                        _, differences := Arguments(expected).Diff(call.Arguments)

                        if differences == 0 </span><span class="cov8" title="1">{
                                // found the expected call
                                return true
                        }</span>

                }
        }
        // we didn't find the expected call
        <span class="cov8" title="1">return false</span>
}

func (m *Mock) expectedCalls() []*Call <span class="cov8" title="1">{
        return append([]*Call{}, m.ExpectedCalls...)
}</span>

func (m *Mock) calls() []Call <span class="cov8" title="1">{
        return append([]Call{}, m.Calls...)
}</span>

/*
        Arguments
*/

// Arguments holds an array of method arguments or return values.
type Arguments []interface{}

const (
        // Anything is used in Diff and Assert when the argument being tested
        // shouldn't be taken into consideration.
        Anything = "mock.Anything"
)

// AnythingOfTypeArgument contains the type of an argument
// for use when type checking.  Used in [Arguments.Diff] and [Arguments.Assert].
//
// Deprecated: this is an implementation detail that must not be used. Use the [AnythingOfType] constructor instead, example:
//
//        m.On("Do", mock.AnythingOfType("string"))
//
// All explicit type declarations can be replaced with interface{} as is expected by [Mock.On], example:
//
//        func anyString interface{} {
//                return mock.AnythingOfType("string")
//        }
type AnythingOfTypeArgument = anythingOfTypeArgument

// anythingOfTypeArgument is a string that contains the type of an argument
// for use when type checking.  Used in Diff and Assert.
type anythingOfTypeArgument string

// AnythingOfType returns a special value containing the
// name of the type to check for. The type name will be matched against the type name returned by [reflect.Type.String].
//
// Used in Diff and Assert.
//
// For example:
//
//        args.Assert(t, AnythingOfType("string"), AnythingOfType("int"))
func AnythingOfType(t string) AnythingOfTypeArgument <span class="cov8" title="1">{
        return anythingOfTypeArgument(t)
}</span>

// IsTypeArgument is a struct that contains the type of an argument
// for use when type checking.  This is an alternative to [AnythingOfType].
// Used in [Arguments.Diff] and [Arguments.Assert].
type IsTypeArgument struct {
        t reflect.Type
}

// IsType returns an IsTypeArgument object containing the type to check for.
// You can provide a zero-value of the type to check.  This is an
// alternative to [AnythingOfType].  Used in [Arguments.Diff] and [Arguments.Assert].
//
// For example:
//
//        args.Assert(t, IsType(""), IsType(0))
func IsType(t interface{}) *IsTypeArgument <span class="cov8" title="1">{
        return &amp;IsTypeArgument{t: reflect.TypeOf(t)}
}</span>

// FunctionalOptionsArgument contains a list of functional options arguments
// expected for use when matching a list of arguments.
type FunctionalOptionsArgument struct {
        values []interface{}
}

// String returns the string representation of FunctionalOptionsArgument
func (f *FunctionalOptionsArgument) String() string <span class="cov8" title="1">{
        var name string
        if len(f.values) &gt; 0 </span><span class="cov8" title="1">{
                name = "[]" + reflect.TypeOf(f.values[0]).String()
        }</span>

        <span class="cov8" title="1">return strings.Replace(fmt.Sprintf("%#v", f.values), "[]interface {}", name, 1)</span>
}

// FunctionalOptions returns an [FunctionalOptionsArgument] object containing
// the expected functional-options to check for.
//
// For example:
//
//        args.Assert(t, FunctionalOptions(foo.Opt1("strValue"), foo.Opt2(613)))
func FunctionalOptions(values ...interface{}) *FunctionalOptionsArgument <span class="cov8" title="1">{
        return &amp;FunctionalOptionsArgument{
                values: values,
        }
}</span>

// argumentMatcher performs custom argument matching, returning whether or
// not the argument is matched by the expectation fixture function.
type argumentMatcher struct {
        // fn is a function which accepts one argument, and returns a bool.
        fn reflect.Value
}

func (f argumentMatcher) Matches(argument interface{}) bool <span class="cov8" title="1">{
        expectType := f.fn.Type().In(0)
        expectTypeNilSupported := false
        switch expectType.Kind() </span>{
        case reflect.Interface, reflect.Chan, reflect.Func, reflect.Map, reflect.Slice, reflect.Ptr:<span class="cov8" title="1">
                expectTypeNilSupported = true</span>
        }

        <span class="cov8" title="1">argType := reflect.TypeOf(argument)
        var arg reflect.Value
        if argType == nil </span><span class="cov8" title="1">{
                arg = reflect.New(expectType).Elem()
        }</span> else<span class="cov8" title="1"> {
                arg = reflect.ValueOf(argument)
        }</span>

        <span class="cov8" title="1">if argType == nil &amp;&amp; !expectTypeNilSupported </span><span class="cov0" title="0">{
                panic(errors.New("attempting to call matcher with nil for non-nil expected type"))</span>
        }
        <span class="cov8" title="1">if argType == nil || argType.AssignableTo(expectType) </span><span class="cov8" title="1">{
                result := f.fn.Call([]reflect.Value{arg})
                return result[0].Bool()
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (f argumentMatcher) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("func(%s) bool", f.fn.Type().In(0).String())
}</span>

// MatchedBy can be used to match a mock call based on only certain properties
// from a complex struct or some calculation. It takes a function that will be
// evaluated with the called argument and will return true when there's a match
// and false otherwise.
//
// Example:
//
//        m.On("Do", MatchedBy(func(req *http.Request) bool { return req.Host == "example.com" }))
//
// fn must be a function accepting a single argument (of the expected type)
// which returns a bool. If fn doesn't match the required signature,
// MatchedBy() panics.
func MatchedBy(fn interface{}) argumentMatcher <span class="cov8" title="1">{
        fnType := reflect.TypeOf(fn)

        if fnType.Kind() != reflect.Func </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: %s is not a func", fn))</span>
        }
        <span class="cov8" title="1">if fnType.NumIn() != 1 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: %s does not take exactly one argument", fn))</span>
        }
        <span class="cov8" title="1">if fnType.NumOut() != 1 || fnType.Out(0).Kind() != reflect.Bool </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: %s does not return a bool", fn))</span>
        }

        <span class="cov8" title="1">return argumentMatcher{fn: reflect.ValueOf(fn)}</span>
}

// Get Returns the argument at the specified index.
func (args Arguments) Get(index int) interface{} <span class="cov8" title="1">{
        if index+1 &gt; len(args) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: Cannot call Get(%d) because there are %d argument(s).", index, len(args)))</span>
        }
        <span class="cov8" title="1">return args[index]</span>
}

// Is gets whether the objects match the arguments specified.
func (args Arguments) Is(objects ...interface{}) bool <span class="cov8" title="1">{
        for i, obj := range args </span><span class="cov8" title="1">{
                if obj != objects[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Diff gets a string describing the differences between the arguments
// and the specified objects.
//
// Returns the diff string and number of differences found.
func (args Arguments) Diff(objects []interface{}) (string, int) <span class="cov8" title="1">{
        // TODO: could return string as error and nil for No difference

        output := "\n"
        var differences int

        maxArgCount := len(args)
        if len(objects) &gt; maxArgCount </span><span class="cov8" title="1">{
                maxArgCount = len(objects)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; maxArgCount; i++ </span><span class="cov8" title="1">{
                var actual, expected interface{}
                var actualFmt, expectedFmt string

                if len(objects) &lt;= i </span><span class="cov8" title="1">{
                        actual = "(Missing)"
                        actualFmt = "(Missing)"
                }</span> else<span class="cov8" title="1"> {
                        actual = objects[i]
                        actualFmt = fmt.Sprintf("(%[1]T=%[1]v)", actual)
                }</span>

                <span class="cov8" title="1">if len(args) &lt;= i </span><span class="cov8" title="1">{
                        expected = "(Missing)"
                        expectedFmt = "(Missing)"
                }</span> else<span class="cov8" title="1"> {
                        expected = args[i]
                        expectedFmt = fmt.Sprintf("(%[1]T=%[1]v)", expected)
                }</span>

                <span class="cov8" title="1">if matcher, ok := expected.(argumentMatcher); ok </span><span class="cov8" title="1">{
                        var matches bool
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                                actualFmt = fmt.Sprintf("panic in argument matcher: %v", r)
                                        }</span>
                                }()
                                <span class="cov8" title="1">matches = matcher.Matches(actual)</span>
                        }()
                        <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                                output = fmt.Sprintf("%s\t%d: PASS:  %s matched by %s\n", output, i, actualFmt, matcher)
                        }</span> else<span class="cov8" title="1"> {
                                differences++
                                output = fmt.Sprintf("%s\t%d: FAIL:  %s not matched by %s\n", output, i, actualFmt, matcher)
                        }</span>
                } else<span class="cov8" title="1"> {
                        switch expected := expected.(type) </span>{
                        case anythingOfTypeArgument:<span class="cov8" title="1">
                                // type checking
                                if reflect.TypeOf(actual).Name() != string(expected) &amp;&amp; reflect.TypeOf(actual).String() != string(expected) </span><span class="cov8" title="1">{
                                        // not match
                                        differences++
                                        output = fmt.Sprintf("%s\t%d: FAIL:  type %s != type %s - %s\n", output, i, expected, reflect.TypeOf(actual).Name(), actualFmt)
                                }</span>
                        case *IsTypeArgument:<span class="cov8" title="1">
                                actualT := reflect.TypeOf(actual)
                                if actualT != expected.t </span><span class="cov8" title="1">{
                                        differences++
                                        output = fmt.Sprintf("%s\t%d: FAIL:  type %s != type %s - %s\n", output, i, expected.t.Name(), actualT.Name(), actualFmt)
                                }</span>
                        case *FunctionalOptionsArgument:<span class="cov8" title="1">
                                var name string
                                if len(expected.values) &gt; 0 </span><span class="cov8" title="1">{
                                        name = "[]" + reflect.TypeOf(expected.values[0]).String()
                                }</span>

                                <span class="cov8" title="1">const tName = "[]interface{}"
                                if name != reflect.TypeOf(actual).String() &amp;&amp; len(expected.values) != 0 </span><span class="cov0" title="0">{
                                        differences++
                                        output = fmt.Sprintf("%s\t%d: FAIL:  type %s != type %s - %s\n", output, i, tName, reflect.TypeOf(actual).Name(), actualFmt)
                                }</span> else<span class="cov8" title="1"> {
                                        if ef, af := assertOpts(expected.values, actual); ef == "" &amp;&amp; af == "" </span><span class="cov8" title="1">{
                                                // match
                                                output = fmt.Sprintf("%s\t%d: PASS:  %s == %s\n", output, i, tName, tName)
                                        }</span> else<span class="cov8" title="1"> {
                                                // not match
                                                differences++
                                                output = fmt.Sprintf("%s\t%d: FAIL:  %s != %s\n", output, i, af, ef)
                                        }</span>
                                }

                        default:<span class="cov8" title="1">
                                if assert.ObjectsAreEqual(expected, Anything) || assert.ObjectsAreEqual(actual, Anything) || assert.ObjectsAreEqual(actual, expected) </span><span class="cov8" title="1">{
                                        // match
                                        output = fmt.Sprintf("%s\t%d: PASS:  %s == %s\n", output, i, actualFmt, expectedFmt)
                                }</span> else<span class="cov8" title="1"> {
                                        // not match
                                        differences++
                                        output = fmt.Sprintf("%s\t%d: FAIL:  %s != %s\n", output, i, actualFmt, expectedFmt)
                                }</span>
                        }
                }

        }

        <span class="cov8" title="1">if differences == 0 </span><span class="cov8" title="1">{
                return "No differences.", differences
        }</span>

        <span class="cov8" title="1">return output, differences</span>
}

// Assert compares the arguments with the specified objects and fails if
// they do not exactly match.
func (args Arguments) Assert(t TestingT, objects ...interface{}) bool <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>

        // get the differences
        <span class="cov8" title="1">diff, diffCount := args.Diff(objects)

        if diffCount == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // there are differences... report them...
        <span class="cov0" title="0">t.Logf(diff)
        t.Errorf("%sArguments do not match.", assert.CallerInfo())

        return false</span>
}

// String gets the argument at the specified index. Panics if there is no argument, or
// if the argument is of the wrong type.
//
// If no index is provided, String() returns a complete string representation
// of the arguments.
func (args Arguments) String(indexOrNil ...int) string <span class="cov8" title="1">{
        if len(indexOrNil) == 0 </span><span class="cov8" title="1">{
                // normal String() method - return a string representation of the args
                var argsStr []string
                for _, arg := range args </span><span class="cov8" title="1">{
                        argsStr = append(argsStr, fmt.Sprintf("%T", arg)) // handles nil nicely
                }</span>
                <span class="cov8" title="1">return strings.Join(argsStr, ",")</span>
        } else<span class="cov8" title="1"> if len(indexOrNil) == 1 </span><span class="cov8" title="1">{
                // Index has been specified - get the argument at that index
                index := indexOrNil[0]
                var s string
                var ok bool
                if s, ok = args.Get(index).(string); !ok </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("assert: arguments: String(%d) failed because object wasn't correct type: %s", index, args.Get(index)))</span>
                }
                <span class="cov8" title="1">return s</span>
        }

        <span class="cov0" title="0">panic(fmt.Sprintf("assert: arguments: Wrong number of arguments passed to String.  Must be 0 or 1, not %d", len(indexOrNil)))</span>
}

// Int gets the argument at the specified index. Panics if there is no argument, or
// if the argument is of the wrong type.
func (args Arguments) Int(index int) int <span class="cov8" title="1">{
        var s int
        var ok bool
        if s, ok = args.Get(index).(int); !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: Int(%d) failed because object wasn't correct type: %v", index, args.Get(index)))</span>
        }
        <span class="cov8" title="1">return s</span>
}

// Error gets the argument at the specified index. Panics if there is no argument, or
// if the argument is of the wrong type.
func (args Arguments) Error(index int) error <span class="cov8" title="1">{
        obj := args.Get(index)
        var s error
        var ok bool
        if obj == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if s, ok = obj.(error); !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: Error(%d) failed because object wasn't correct type: %v", index, obj))</span>
        }
        <span class="cov8" title="1">return s</span>
}

// Bool gets the argument at the specified index. Panics if there is no argument, or
// if the argument is of the wrong type.
func (args Arguments) Bool(index int) bool <span class="cov8" title="1">{
        var s bool
        var ok bool
        if s, ok = args.Get(index).(bool); !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assert: arguments: Bool(%d) failed because object wasn't correct type: %v", index, args.Get(index)))</span>
        }
        <span class="cov8" title="1">return s</span>
}

func typeAndKind(v interface{}) (reflect.Type, reflect.Kind) <span class="cov8" title="1">{
        t := reflect.TypeOf(v)
        k := t.Kind()

        if k == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
                k = t.Kind()
        }</span>
        <span class="cov8" title="1">return t, k</span>
}

func diffArguments(expected Arguments, actual Arguments) string <span class="cov8" title="1">{
        if len(expected) != len(actual) </span><span class="cov0" title="0">{
                return fmt.Sprintf("Provided %v arguments, mocked for %v arguments", len(expected), len(actual))
        }</span>

        <span class="cov8" title="1">for x := range expected </span><span class="cov8" title="1">{
                if diffString := diff(expected[x], actual[x]); diffString != "" </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Difference found in argument %v:\n\n%s", x, diffString)
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// diff returns a diff of both values as long as both are of the same type and
// are a struct, map, slice or array. Otherwise it returns an empty string.
func diff(expected interface{}, actual interface{}) string <span class="cov8" title="1">{
        if expected == nil || actual == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">et, ek := typeAndKind(expected)
        at, _ := typeAndKind(actual)

        if et != at </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if ek != reflect.Struct &amp;&amp; ek != reflect.Map &amp;&amp; ek != reflect.Slice &amp;&amp; ek != reflect.Array </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">e := spewConfig.Sdump(expected)
        a := spewConfig.Sdump(actual)

        diff, _ := difflib.GetUnifiedDiffString(difflib.UnifiedDiff{
                A:        difflib.SplitLines(e),
                B:        difflib.SplitLines(a),
                FromFile: "Expected",
                FromDate: "",
                ToFile:   "Actual",
                ToDate:   "",
                Context:  1,
        })

        return diff</span>
}

var spewConfig = spew.ConfigState{
        Indent:                  " ",
        DisablePointerAddresses: true,
        DisableCapacities:       true,
        SortKeys:                true,
}

type tHelper interface {
        Helper()
}

func assertOpts(expected, actual interface{}) (expectedFmt, actualFmt string) <span class="cov8" title="1">{
        expectedOpts := reflect.ValueOf(expected)
        actualOpts := reflect.ValueOf(actual)

        var expectedFuncs []*runtime.Func
        var expectedNames []string
        for i := 0; i &lt; expectedOpts.Len(); i++ </span><span class="cov8" title="1">{
                f := runtimeFunc(expectedOpts.Index(i).Interface())
                expectedFuncs = append(expectedFuncs, f)
                expectedNames = append(expectedNames, funcName(f))
        }</span>
        <span class="cov8" title="1">var actualFuncs []*runtime.Func
        var actualNames []string
        for i := 0; i &lt; actualOpts.Len(); i++ </span><span class="cov8" title="1">{
                f := runtimeFunc(actualOpts.Index(i).Interface())
                actualFuncs = append(actualFuncs, f)
                actualNames = append(actualNames, funcName(f))
        }</span>

        <span class="cov8" title="1">if expectedOpts.Len() != actualOpts.Len() </span><span class="cov0" title="0">{
                expectedFmt = fmt.Sprintf("%v", expectedNames)
                actualFmt = fmt.Sprintf("%v", actualNames)
                return
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; expectedOpts.Len(); i++ </span><span class="cov8" title="1">{
                if !isFuncSame(expectedFuncs[i], actualFuncs[i]) </span><span class="cov8" title="1">{
                        expectedFmt = expectedNames[i]
                        actualFmt = actualNames[i]
                        return
                }</span>

                <span class="cov8" title="1">expectedOpt := expectedOpts.Index(i).Interface()
                actualOpt := actualOpts.Index(i).Interface()

                ot := reflect.TypeOf(expectedOpt)
                var expectedValues []reflect.Value
                var actualValues []reflect.Value
                if ot.NumIn() == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; ot.NumIn(); i++ </span><span class="cov8" title="1">{
                        vt := ot.In(i).Elem()
                        expectedValues = append(expectedValues, reflect.New(vt))
                        actualValues = append(actualValues, reflect.New(vt))
                }</span>

                <span class="cov8" title="1">reflect.ValueOf(expectedOpt).Call(expectedValues)
                reflect.ValueOf(actualOpt).Call(actualValues)

                for i := 0; i &lt; ot.NumIn(); i++ </span><span class="cov8" title="1">{
                        if expectedArg, actualArg := expectedValues[i].Interface(), actualValues[i].Interface(); !assert.ObjectsAreEqual(expectedArg, actualArg) </span><span class="cov8" title="1">{
                                expectedFmt = fmt.Sprintf("%s(%T) -&gt; %#v", expectedNames[i], expectedArg, expectedArg)
                                actualFmt = fmt.Sprintf("%s(%T) -&gt; %#v", expectedNames[i], actualArg, actualArg)
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">return "", ""</span>
}

func runtimeFunc(opt interface{}) *runtime.Func <span class="cov8" title="1">{
        return runtime.FuncForPC(reflect.ValueOf(opt).Pointer())
}</span>

func funcName(f *runtime.Func) string <span class="cov8" title="1">{
        name := f.Name()
        trimmed := strings.TrimSuffix(path.Base(name), path.Ext(name))
        splitted := strings.Split(trimmed, ".")

        if len(splitted) == 0 </span><span class="cov0" title="0">{
                return trimmed
        }</span>

        <span class="cov8" title="1">return splitted[len(splitted)-1]</span>
}

func isFuncSame(f1, f2 *runtime.Func) bool <span class="cov8" title="1">{
        f1File, f1Loc := f1.FileLine(f1.Entry())
        f2File, f2Loc := f2.FileLine(f2.Entry())

        return f1File == f2File &amp;&amp; f1Loc == f2Loc
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package require

// Assertions provides assertion methods around the
// TestingT interface.
type Assertions struct {
        t TestingT
}

// New makes a new Assertions object for the specified TestingT.
func New(t TestingT) *Assertions <span class="cov8" title="1">{
        return &amp;Assertions{
                t: t,
        }
}</span>

//go:generate sh -c "cd ../_codegen &amp;&amp; go build &amp;&amp; cd - &amp;&amp; ../_codegen/_codegen -output-package=require -template=require_forward.go.tmpl -include-format-funcs"
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated with github.com/stretchr/testify/_codegen; DO NOT EDIT.

package require

import (
        assert "github.com/stretchr/testify/assert"
        http "net/http"
        url "net/url"
        time "time"
)

// Condition uses a Comparison to assert a complex condition.
func Condition(t TestingT, comp assert.Comparison, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Condition(t, comp, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Conditionf uses a Comparison to assert a complex condition.
func Conditionf(t TestingT, comp assert.Comparison, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Conditionf(t, comp, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Contains asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        require.Contains(t, "Hello World", "World")
//        require.Contains(t, ["Hello", "World"], "World")
//        require.Contains(t, {"Hello": "World"}, "Hello")
func Contains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Contains(t, s, contains, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Containsf asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        require.Containsf(t, "Hello World", "World", "error message %s", "formatted")
//        require.Containsf(t, ["Hello", "World"], "World", "error message %s", "formatted")
//        require.Containsf(t, {"Hello": "World"}, "Hello", "error message %s", "formatted")
func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Containsf(t, s, contains, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// DirExists checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func DirExists(t TestingT, path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.DirExists(t, path, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// DirExistsf checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func DirExistsf(t TestingT, path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.DirExistsf(t, path, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// require.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2])
func ElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.ElementsMatch(t, listA, listB, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// require.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ElementsMatchf(t, listA, listB, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        require.Empty(t, obj)
func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Empty(t, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        require.Emptyf(t, obj, "error message %s", "formatted")
func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Emptyf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Equal asserts that two objects are equal.
//
//        require.Equal(t, 123, 123)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func Equal(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Equal(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// EqualError asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        require.EqualError(t, err,  expectedErrorString)
func EqualError(t TestingT, theError error, errString string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.EqualError(t, theError, errString, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// EqualErrorf asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        require.EqualErrorf(t, err,  expectedErrorString, "error message %s", "formatted")
func EqualErrorf(t TestingT, theError error, errString string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.EqualErrorf(t, theError, errString, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// EqualExportedValues asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         require.EqualExportedValues(t, S{1, 2}, S{1, 3}) =&gt; true
//         require.EqualExportedValues(t, S{1, 2}, S{2, 3}) =&gt; false
func EqualExportedValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.EqualExportedValues(t, expected, actual, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// EqualExportedValuesf asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         require.EqualExportedValuesf(t, S{1, 2}, S{1, 3}, "error message %s", "formatted") =&gt; true
//         require.EqualExportedValuesf(t, S{1, 2}, S{2, 3}, "error message %s", "formatted") =&gt; false
func EqualExportedValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.EqualExportedValuesf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// EqualValues asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        require.EqualValues(t, uint32(123), int32(123))
func EqualValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.EqualValues(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// EqualValuesf asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        require.EqualValuesf(t, uint32(123), int32(123), "error message %s", "formatted")
func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.EqualValuesf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Equalf asserts that two objects are equal.
//
//        require.Equalf(t, 123, 123, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Equalf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Error asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if require.Error(t, err) {
//                   require.Equal(t, expectedError, err)
//          }
func Error(t TestingT, err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Error(t, err, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// ErrorAs asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func ErrorAs(t TestingT, err error, target interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ErrorAs(t, err, target, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func ErrorAsf(t TestingT, err error, target interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ErrorAsf(t, err, target, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ErrorContains asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        require.ErrorContains(t, err,  expectedErrorSubString)
func ErrorContains(t TestingT, theError error, contains string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.ErrorContains(t, theError, contains, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        require.ErrorContainsf(t, err,  expectedErrorSubString, "error message %s", "formatted")
func ErrorContainsf(t TestingT, theError error, contains string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ErrorContainsf(t, theError, contains, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ErrorIs asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func ErrorIs(t TestingT, err error, target error, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ErrorIs(t, err, target, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// ErrorIsf asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func ErrorIsf(t TestingT, err error, target error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.ErrorIsf(t, err, target, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Errorf asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if require.Errorf(t, err, "error message %s", "formatted") {
//                   require.Equal(t, expectedErrorf, err)
//          }
func Errorf(t TestingT, err error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Errorf(t, err, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Eventually asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        require.Eventually(t, func() bool { return true; }, time.Second, 10*time.Millisecond)
func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Eventually(t, condition, waitFor, tick, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// EventuallyWithT asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        require.EventuallyWithT(t, func(c *require.CollectT) {
//                // add assertions as needed; any assertion failure will fail the current tick
//                require.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func EventuallyWithT(t TestingT, condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.EventuallyWithT(t, condition, waitFor, tick, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// EventuallyWithTf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        require.EventuallyWithTf(t, func(c *require.CollectT, "error message %s", "formatted") {
//                // add assertions as needed; any assertion failure will fail the current tick
//                require.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func EventuallyWithTf(t TestingT, condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.EventuallyWithTf(t, condition, waitFor, tick, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Eventuallyf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        require.Eventuallyf(t, func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Eventuallyf(t, condition, waitFor, tick, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Exactly asserts that two objects are equal in value and type.
//
//        require.Exactly(t, int32(123), int64(123))
func Exactly(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Exactly(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Exactlyf asserts that two objects are equal in value and type.
//
//        require.Exactlyf(t, int32(123), int64(123), "error message %s", "formatted")
func Exactlyf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Exactlyf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Fail reports a failure through
func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Fail(t, failureMessage, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// FailNow fails test
func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.FailNow(t, failureMessage, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// FailNowf fails test
func FailNowf(t TestingT, failureMessage string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.FailNowf(t, failureMessage, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Failf reports a failure through
func Failf(t TestingT, failureMessage string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Failf(t, failureMessage, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// False asserts that the specified value is false.
//
//        require.False(t, myBool)
func False(t TestingT, value bool, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.False(t, value, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Falsef asserts that the specified value is false.
//
//        require.Falsef(t, myBool, "error message %s", "formatted")
func Falsef(t TestingT, value bool, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Falsef(t, value, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// FileExists checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func FileExists(t TestingT, path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.FileExists(t, path, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// FileExistsf checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func FileExistsf(t TestingT, path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.FileExistsf(t, path, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Greater asserts that the first element is greater than the second
//
//        require.Greater(t, 2, 1)
//        require.Greater(t, float64(2), float64(1))
//        require.Greater(t, "b", "a")
func Greater(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Greater(t, e1, e2, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// GreaterOrEqual asserts that the first element is greater than or equal to the second
//
//        require.GreaterOrEqual(t, 2, 1)
//        require.GreaterOrEqual(t, 2, 2)
//        require.GreaterOrEqual(t, "b", "a")
//        require.GreaterOrEqual(t, "b", "b")
func GreaterOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.GreaterOrEqual(t, e1, e2, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// GreaterOrEqualf asserts that the first element is greater than or equal to the second
//
//        require.GreaterOrEqualf(t, 2, 1, "error message %s", "formatted")
//        require.GreaterOrEqualf(t, 2, 2, "error message %s", "formatted")
//        require.GreaterOrEqualf(t, "b", "a", "error message %s", "formatted")
//        require.GreaterOrEqualf(t, "b", "b", "error message %s", "formatted")
func GreaterOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.GreaterOrEqualf(t, e1, e2, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Greaterf asserts that the first element is greater than the second
//
//        require.Greaterf(t, 2, 1, "error message %s", "formatted")
//        require.Greaterf(t, float64(2), float64(1), "error message %s", "formatted")
//        require.Greaterf(t, "b", "a", "error message %s", "formatted")
func Greaterf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Greaterf(t, e1, e2, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPBodyContains asserts that a specified handler returns a
// body that contains a string.
//
//        require.HTTPBodyContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPBodyContains(t, handler, method, url, values, str, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPBodyContainsf asserts that a specified handler returns a
// body that contains a string.
//
//        require.HTTPBodyContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPBodyContainsf(t, handler, method, url, values, str, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPBodyNotContains asserts that a specified handler returns a
// body that does not contain a string.
//
//        require.HTTPBodyNotContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyNotContains(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPBodyNotContains(t, handler, method, url, values, str, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPBodyNotContainsf asserts that a specified handler returns a
// body that does not contain a string.
//
//        require.HTTPBodyNotContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPBodyNotContainsf(t, handler, method, url, values, str, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPError asserts that a specified handler returns an error status code.
//
//        require.HTTPError(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPError(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPError(t, handler, method, url, values, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPErrorf asserts that a specified handler returns an error status code.
//
//        require.HTTPErrorf(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPErrorf(t, handler, method, url, values, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPRedirect asserts that a specified handler returns a redirect status code.
//
//        require.HTTPRedirect(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPRedirect(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPRedirect(t, handler, method, url, values, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPRedirectf asserts that a specified handler returns a redirect status code.
//
//        require.HTTPRedirectf(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPRedirectf(t, handler, method, url, values, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPStatusCode asserts that a specified handler returns a specified status code.
//
//        require.HTTPStatusCode(t, myHandler, "GET", "/notImplemented", nil, 501)
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPStatusCode(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPStatusCode(t, handler, method, url, values, statuscode, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
//        require.HTTPStatusCodef(t, myHandler, "GET", "/notImplemented", nil, 501, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPStatusCodef(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPStatusCodef(t, handler, method, url, values, statuscode, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPSuccess asserts that a specified handler returns a success status code.
//
//        require.HTTPSuccess(t, myHandler, "POST", "http://www.google.com", nil)
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPSuccess(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPSuccess(t, handler, method, url, values, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// HTTPSuccessf asserts that a specified handler returns a success status code.
//
//        require.HTTPSuccessf(t, myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func HTTPSuccessf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.HTTPSuccessf(t, handler, method, url, values, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Implements asserts that an object is implemented by the specified interface.
//
//        require.Implements(t, (*MyInterface)(nil), new(MyObject))
func Implements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Implements(t, interfaceObject, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Implementsf asserts that an object is implemented by the specified interface.
//
//        require.Implementsf(t, (*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func Implementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Implementsf(t, interfaceObject, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InDelta asserts that the two numerals are within delta of each other.
//
//        require.InDelta(t, math.Pi, 22/7.0, 0.01)
func InDelta(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.InDelta(t, expected, actual, delta, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func InDeltaMapValues(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InDeltaMapValues(t, expected, actual, delta, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func InDeltaMapValuesf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InDeltaMapValuesf(t, expected, actual, delta, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InDeltaSlice is the same as InDelta, except it compares two slices.
func InDeltaSlice(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InDeltaSlice(t, expected, actual, delta, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
func InDeltaSlicef(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InDeltaSlicef(t, expected, actual, delta, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InDeltaf asserts that the two numerals are within delta of each other.
//
//        require.InDeltaf(t, math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
func InDeltaf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InDeltaf(t, expected, actual, delta, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InEpsilon asserts that expected and actual have a relative error less than epsilon
func InEpsilon(t TestingT, expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InEpsilon(t, expected, actual, epsilon, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func InEpsilonSlice(t TestingT, expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InEpsilonSlice(t, expected, actual, epsilon, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
func InEpsilonSlicef(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InEpsilonSlicef(t, expected, actual, epsilon, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// InEpsilonf asserts that expected and actual have a relative error less than epsilon
func InEpsilonf(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.InEpsilonf(t, expected, actual, epsilon, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsDecreasing asserts that the collection is decreasing
//
//        require.IsDecreasing(t, []int{2, 1, 0})
//        require.IsDecreasing(t, []float{2, 1})
//        require.IsDecreasing(t, []string{"b", "a"})
func IsDecreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsDecreasing(t, object, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsDecreasingf asserts that the collection is decreasing
//
//        require.IsDecreasingf(t, []int{2, 1, 0}, "error message %s", "formatted")
//        require.IsDecreasingf(t, []float{2, 1}, "error message %s", "formatted")
//        require.IsDecreasingf(t, []string{"b", "a"}, "error message %s", "formatted")
func IsDecreasingf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsDecreasingf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsIncreasing asserts that the collection is increasing
//
//        require.IsIncreasing(t, []int{1, 2, 3})
//        require.IsIncreasing(t, []float{1, 2})
//        require.IsIncreasing(t, []string{"a", "b"})
func IsIncreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsIncreasing(t, object, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsIncreasingf asserts that the collection is increasing
//
//        require.IsIncreasingf(t, []int{1, 2, 3}, "error message %s", "formatted")
//        require.IsIncreasingf(t, []float{1, 2}, "error message %s", "formatted")
//        require.IsIncreasingf(t, []string{"a", "b"}, "error message %s", "formatted")
func IsIncreasingf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsIncreasingf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsNonDecreasing asserts that the collection is not decreasing
//
//        require.IsNonDecreasing(t, []int{1, 1, 2})
//        require.IsNonDecreasing(t, []float{1, 2})
//        require.IsNonDecreasing(t, []string{"a", "b"})
func IsNonDecreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsNonDecreasing(t, object, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsNonDecreasingf asserts that the collection is not decreasing
//
//        require.IsNonDecreasingf(t, []int{1, 1, 2}, "error message %s", "formatted")
//        require.IsNonDecreasingf(t, []float{1, 2}, "error message %s", "formatted")
//        require.IsNonDecreasingf(t, []string{"a", "b"}, "error message %s", "formatted")
func IsNonDecreasingf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsNonDecreasingf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsNonIncreasing asserts that the collection is not increasing
//
//        require.IsNonIncreasing(t, []int{2, 1, 1})
//        require.IsNonIncreasing(t, []float{2, 1})
//        require.IsNonIncreasing(t, []string{"b", "a"})
func IsNonIncreasing(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsNonIncreasing(t, object, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsNonIncreasingf asserts that the collection is not increasing
//
//        require.IsNonIncreasingf(t, []int{2, 1, 1}, "error message %s", "formatted")
//        require.IsNonIncreasingf(t, []float{2, 1}, "error message %s", "formatted")
//        require.IsNonIncreasingf(t, []string{"b", "a"}, "error message %s", "formatted")
func IsNonIncreasingf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsNonIncreasingf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// IsType asserts that the specified objects are of the same type.
func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.IsType(t, expectedType, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// IsTypef asserts that the specified objects are of the same type.
func IsTypef(t TestingT, expectedType interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.IsTypef(t, expectedType, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// JSONEq asserts that two JSON strings are equivalent.
//
//        require.JSONEq(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
func JSONEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.JSONEq(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// JSONEqf asserts that two JSON strings are equivalent.
//
//        require.JSONEqf(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
func JSONEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.JSONEqf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Len asserts that the specified object has specific length.
// Len also fails if the object has a type that len() not accept.
//
//        require.Len(t, mySlice, 3)
func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Len(t, object, length, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Lenf asserts that the specified object has specific length.
// Lenf also fails if the object has a type that len() not accept.
//
//        require.Lenf(t, mySlice, 3, "error message %s", "formatted")
func Lenf(t TestingT, object interface{}, length int, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Lenf(t, object, length, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Less asserts that the first element is less than the second
//
//        require.Less(t, 1, 2)
//        require.Less(t, float64(1), float64(2))
//        require.Less(t, "a", "b")
func Less(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Less(t, e1, e2, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// LessOrEqual asserts that the first element is less than or equal to the second
//
//        require.LessOrEqual(t, 1, 2)
//        require.LessOrEqual(t, 2, 2)
//        require.LessOrEqual(t, "a", "b")
//        require.LessOrEqual(t, "b", "b")
func LessOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.LessOrEqual(t, e1, e2, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// LessOrEqualf asserts that the first element is less than or equal to the second
//
//        require.LessOrEqualf(t, 1, 2, "error message %s", "formatted")
//        require.LessOrEqualf(t, 2, 2, "error message %s", "formatted")
//        require.LessOrEqualf(t, "a", "b", "error message %s", "formatted")
//        require.LessOrEqualf(t, "b", "b", "error message %s", "formatted")
func LessOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.LessOrEqualf(t, e1, e2, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Lessf asserts that the first element is less than the second
//
//        require.Lessf(t, 1, 2, "error message %s", "formatted")
//        require.Lessf(t, float64(1), float64(2), "error message %s", "formatted")
//        require.Lessf(t, "a", "b", "error message %s", "formatted")
func Lessf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Lessf(t, e1, e2, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Negative asserts that the specified element is negative
//
//        require.Negative(t, -1)
//        require.Negative(t, -1.23)
func Negative(t TestingT, e interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Negative(t, e, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Negativef asserts that the specified element is negative
//
//        require.Negativef(t, -1, "error message %s", "formatted")
//        require.Negativef(t, -1.23, "error message %s", "formatted")
func Negativef(t TestingT, e interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Negativef(t, e, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Never asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        require.Never(t, func() bool { return false; }, time.Second, 10*time.Millisecond)
func Never(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Never(t, condition, waitFor, tick, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Neverf asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        require.Neverf(t, func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func Neverf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Neverf(t, condition, waitFor, tick, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Nil asserts that the specified object is nil.
//
//        require.Nil(t, err)
func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Nil(t, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Nilf asserts that the specified object is nil.
//
//        require.Nilf(t, err, "error message %s", "formatted")
func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Nilf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NoDirExists checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func NoDirExists(t TestingT, path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NoDirExists(t, path, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NoDirExistsf checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func NoDirExistsf(t TestingT, path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NoDirExistsf(t, path, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NoError asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if require.NoError(t, err) {
//                   require.Equal(t, expectedObj, actualObj)
//          }
func NoError(t TestingT, err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NoError(t, err, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NoErrorf asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if require.NoErrorf(t, err, "error message %s", "formatted") {
//                   require.Equal(t, expectedObj, actualObj)
//          }
func NoErrorf(t TestingT, err error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NoErrorf(t, err, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NoFileExists checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func NoFileExists(t TestingT, path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NoFileExists(t, path, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func NoFileExistsf(t TestingT, path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NoFileExistsf(t, path, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        require.NotContains(t, "Hello World", "Earth")
//        require.NotContains(t, ["Hello", "World"], "Earth")
//        require.NotContains(t, {"Hello": "World"}, "Earth")
func NotContains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotContains(t, s, contains, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        require.NotContainsf(t, "Hello World", "Earth", "error message %s", "formatted")
//        require.NotContainsf(t, ["Hello", "World"], "Earth", "error message %s", "formatted")
//        require.NotContainsf(t, {"Hello": "World"}, "Earth", "error message %s", "formatted")
func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotContainsf(t, s, contains, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// require.NotElementsMatch(t, [1, 1, 2, 3], [1, 1, 2, 3]) -&gt; false
//
// require.NotElementsMatch(t, [1, 1, 2, 3], [1, 2, 3]) -&gt; true
//
// require.NotElementsMatch(t, [1, 2, 3], [1, 2, 4]) -&gt; true
func NotElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotElementsMatch(t, listA, listB, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// require.NotElementsMatchf(t, [1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -&gt; false
//
// require.NotElementsMatchf(t, [1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -&gt; true
//
// require.NotElementsMatchf(t, [1, 2, 3], [1, 2, 4], "error message %s", "formatted") -&gt; true
func NotElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotElementsMatchf(t, listA, listB, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if require.NotEmpty(t, obj) {
//          require.Equal(t, "two", obj[1])
//        }
func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotEmpty(t, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if require.NotEmptyf(t, obj, "error message %s", "formatted") {
//          require.Equal(t, "two", obj[1])
//        }
func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotEmptyf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotEqual asserts that the specified values are NOT equal.
//
//        require.NotEqual(t, obj1, obj2)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func NotEqual(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotEqual(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotEqualValues asserts that two objects are not equal even when converted to the same type
//
//        require.NotEqualValues(t, obj1, obj2)
func NotEqualValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotEqualValues(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
//
//        require.NotEqualValuesf(t, obj1, obj2, "error message %s", "formatted")
func NotEqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotEqualValuesf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotEqualf asserts that the specified values are NOT equal.
//
//        require.NotEqualf(t, obj1, obj2, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func NotEqualf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotEqualf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotErrorAs asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func NotErrorAs(t TestingT, err error, target interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotErrorAs(t, err, target, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotErrorAsf asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func NotErrorAsf(t TestingT, err error, target interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotErrorAsf(t, err, target, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotErrorIs asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func NotErrorIs(t TestingT, err error, target error, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotErrorIs(t, err, target, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotErrorIsf asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func NotErrorIsf(t TestingT, err error, target error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotErrorIsf(t, err, target, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotImplements asserts that an object does not implement the specified interface.
//
//        require.NotImplements(t, (*MyInterface)(nil), new(MyObject))
func NotImplements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotImplements(t, interfaceObject, object, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotImplementsf asserts that an object does not implement the specified interface.
//
//        require.NotImplementsf(t, (*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func NotImplementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotImplementsf(t, interfaceObject, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotNil asserts that the specified object is not nil.
//
//        require.NotNil(t, err)
func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotNil(t, object, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotNilf asserts that the specified object is not nil.
//
//        require.NotNilf(t, err, "error message %s", "formatted")
func NotNilf(t TestingT, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotNilf(t, object, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        require.NotPanics(t, func(){ RemainCalm() })
func NotPanics(t TestingT, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotPanics(t, f, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        require.NotPanicsf(t, func(){ RemainCalm() }, "error message %s", "formatted")
func NotPanicsf(t TestingT, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotPanicsf(t, f, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotRegexp asserts that a specified regexp does not match a string.
//
//        require.NotRegexp(t, regexp.MustCompile("starts"), "it's starting")
//        require.NotRegexp(t, "^start", "it's not starting")
func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotRegexp(t, rx, str, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotRegexpf asserts that a specified regexp does not match a string.
//
//        require.NotRegexpf(t, regexp.MustCompile("starts"), "it's starting", "error message %s", "formatted")
//        require.NotRegexpf(t, "^start", "it's not starting", "error message %s", "formatted")
func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotRegexpf(t, rx, str, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotSame asserts that two pointers do not reference the same object.
//
//        require.NotSame(t, ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func NotSame(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotSame(t, expected, actual, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotSamef asserts that two pointers do not reference the same object.
//
//        require.NotSamef(t, ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func NotSamef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotSamef(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotSubset asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        require.NotSubset(t, [1, 3, 4], [1, 2])
//        require.NotSubset(t, {"x": 1, "y": 2}, {"z": 3})
func NotSubset(t TestingT, list interface{}, subset interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotSubset(t, list, subset, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotSubsetf asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        require.NotSubsetf(t, [1, 3, 4], [1, 2], "error message %s", "formatted")
//        require.NotSubsetf(t, {"x": 1, "y": 2}, {"z": 3}, "error message %s", "formatted")
func NotSubsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotSubsetf(t, list, subset, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// NotZero asserts that i is not the zero value for its type.
func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.NotZero(t, i, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// NotZerof asserts that i is not the zero value for its type.
func NotZerof(t TestingT, i interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.NotZerof(t, i, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Panics asserts that the code inside the specified PanicTestFunc panics.
//
//        require.Panics(t, func(){ GoCrazy() })
func Panics(t TestingT, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Panics(t, f, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// PanicsWithError asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        require.PanicsWithError(t, "crazy error", func(){ GoCrazy() })
func PanicsWithError(t TestingT, errString string, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.PanicsWithError(t, errString, f, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        require.PanicsWithErrorf(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func PanicsWithErrorf(t TestingT, errString string, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.PanicsWithErrorf(t, errString, f, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        require.PanicsWithValue(t, "crazy error", func(){ GoCrazy() })
func PanicsWithValue(t TestingT, expected interface{}, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.PanicsWithValue(t, expected, f, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        require.PanicsWithValuef(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func PanicsWithValuef(t TestingT, expected interface{}, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.PanicsWithValuef(t, expected, f, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Panicsf asserts that the code inside the specified PanicTestFunc panics.
//
//        require.Panicsf(t, func(){ GoCrazy() }, "error message %s", "formatted")
func Panicsf(t TestingT, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Panicsf(t, f, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Positive asserts that the specified element is positive
//
//        require.Positive(t, 1)
//        require.Positive(t, 1.23)
func Positive(t TestingT, e interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Positive(t, e, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Positivef asserts that the specified element is positive
//
//        require.Positivef(t, 1, "error message %s", "formatted")
//        require.Positivef(t, 1.23, "error message %s", "formatted")
func Positivef(t TestingT, e interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Positivef(t, e, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Regexp asserts that a specified regexp matches a string.
//
//        require.Regexp(t, regexp.MustCompile("start"), "it's starting")
//        require.Regexp(t, "start...$", "it's not starting")
func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Regexp(t, rx, str, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Regexpf asserts that a specified regexp matches a string.
//
//        require.Regexpf(t, regexp.MustCompile("start"), "it's starting", "error message %s", "formatted")
//        require.Regexpf(t, "start...$", "it's not starting", "error message %s", "formatted")
func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Regexpf(t, rx, str, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Same asserts that two pointers reference the same object.
//
//        require.Same(t, ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func Same(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Same(t, expected, actual, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Samef asserts that two pointers reference the same object.
//
//        require.Samef(t, ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func Samef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Samef(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Subset asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        require.Subset(t, [1, 2, 3], [1, 2])
//        require.Subset(t, {"x": 1, "y": 2}, {"x": 1})
func Subset(t TestingT, list interface{}, subset interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Subset(t, list, subset, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Subsetf asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        require.Subsetf(t, [1, 2, 3], [1, 2], "error message %s", "formatted")
//        require.Subsetf(t, {"x": 1, "y": 2}, {"x": 1}, "error message %s", "formatted")
func Subsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Subsetf(t, list, subset, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// True asserts that the specified value is true.
//
//        require.True(t, myBool)
func True(t TestingT, value bool, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.True(t, value, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Truef asserts that the specified value is true.
//
//        require.Truef(t, myBool, "error message %s", "formatted")
func Truef(t TestingT, value bool, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Truef(t, value, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// WithinDuration asserts that the two times are within duration delta of each other.
//
//        require.WithinDuration(t, time.Now(), time.Now(), 10*time.Second)
func WithinDuration(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.WithinDuration(t, expected, actual, delta, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// WithinDurationf asserts that the two times are within duration delta of each other.
//
//        require.WithinDurationf(t, time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
func WithinDurationf(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.WithinDurationf(t, expected, actual, delta, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// WithinRange asserts that a time is within a time range (inclusive).
//
//        require.WithinRange(t, time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second))
func WithinRange(t TestingT, actual time.Time, start time.Time, end time.Time, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.WithinRange(t, actual, start, end, msgAndArgs...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
//        require.WithinRangef(t, time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second), "error message %s", "formatted")
func WithinRangef(t TestingT, actual time.Time, start time.Time, end time.Time, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.WithinRangef(t, actual, start, end, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// YAMLEq asserts that two YAML strings are equivalent.
func YAMLEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.YAMLEq(t, expected, actual, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// YAMLEqf asserts that two YAML strings are equivalent.
func YAMLEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.YAMLEqf(t, expected, actual, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}

// Zero asserts that i is the zero value for its type.
func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">if assert.Zero(t, i, msgAndArgs...) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.FailNow()</span>
}

// Zerof asserts that i is the zero value for its type.
func Zerof(t TestingT, i interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">if assert.Zerof(t, i, msg, args...) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.FailNow()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated with github.com/stretchr/testify/_codegen; DO NOT EDIT.

package require

import (
        assert "github.com/stretchr/testify/assert"
        http "net/http"
        url "net/url"
        time "time"
)

// Condition uses a Comparison to assert a complex condition.
func (a *Assertions) Condition(comp assert.Comparison, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Condition(a.t, comp, msgAndArgs...)</span>
}

// Conditionf uses a Comparison to assert a complex condition.
func (a *Assertions) Conditionf(comp assert.Comparison, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Conditionf(a.t, comp, msg, args...)</span>
}

// Contains asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        a.Contains("Hello World", "World")
//        a.Contains(["Hello", "World"], "World")
//        a.Contains({"Hello": "World"}, "Hello")
func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Contains(a.t, s, contains, msgAndArgs...)</span>
}

// Containsf asserts that the specified string, list(array, slice...) or map contains the
// specified substring or element.
//
//        a.Containsf("Hello World", "World", "error message %s", "formatted")
//        a.Containsf(["Hello", "World"], "World", "error message %s", "formatted")
//        a.Containsf({"Hello": "World"}, "Hello", "error message %s", "formatted")
func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Containsf(a.t, s, contains, msg, args...)</span>
}

// DirExists checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func (a *Assertions) DirExists(path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">DirExists(a.t, path, msgAndArgs...)</span>
}

// DirExistsf checks whether a directory exists in the given path. It also fails
// if the path is a file rather a directory or there is an error checking whether it exists.
func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">DirExistsf(a.t, path, msg, args...)</span>
}

// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ElementsMatch(a.t, listA, listB, msgAndArgs...)</span>
}

// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should match.
//
// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ElementsMatchf(a.t, listA, listB, msg, args...)</span>
}

// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        a.Empty(obj)
func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Empty(a.t, object, msgAndArgs...)</span>
}

// Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        a.Emptyf(obj, "error message %s", "formatted")
func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Emptyf(a.t, object, msg, args...)</span>
}

// Equal asserts that two objects are equal.
//
//        a.Equal(123, 123)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Equal(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualError asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        a.EqualError(err,  expectedErrorString)
func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">EqualError(a.t, theError, errString, msgAndArgs...)</span>
}

// EqualErrorf asserts that a function returned an error (i.e. not `nil`)
// and that it is equal to the provided error.
//
//        actualObj, err := SomeFunction()
//        a.EqualErrorf(err,  expectedErrorString, "error message %s", "formatted")
func (a *Assertions) EqualErrorf(theError error, errString string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EqualErrorf(a.t, theError, errString, msg, args...)</span>
}

// EqualExportedValues asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         a.EqualExportedValues(S{1, 2}, S{1, 3}) =&gt; true
//         a.EqualExportedValues(S{1, 2}, S{2, 3}) =&gt; false
func (a *Assertions) EqualExportedValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EqualExportedValues(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualExportedValuesf asserts that the types of two objects are equal and their public
// fields are also equal. This is useful for comparing structs that have private fields
// that could potentially differ.
//
//         type S struct {
//                Exported             int
//                notExported           int
//         }
//         a.EqualExportedValuesf(S{1, 2}, S{1, 3}, "error message %s", "formatted") =&gt; true
//         a.EqualExportedValuesf(S{1, 2}, S{2, 3}, "error message %s", "formatted") =&gt; false
func (a *Assertions) EqualExportedValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EqualExportedValuesf(a.t, expected, actual, msg, args...)</span>
}

// EqualValues asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        a.EqualValues(uint32(123), int32(123))
func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EqualValues(a.t, expected, actual, msgAndArgs...)</span>
}

// EqualValuesf asserts that two objects are equal or convertible to the larger
// type and equal.
//
//        a.EqualValuesf(uint32(123), int32(123), "error message %s", "formatted")
func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EqualValuesf(a.t, expected, actual, msg, args...)</span>
}

// Equalf asserts that two objects are equal.
//
//        a.Equalf(123, 123, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses). Function equality
// cannot be determined and will always fail.
func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Equalf(a.t, expected, actual, msg, args...)</span>
}

// Error asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.Error(err) {
//                   assert.Equal(t, expectedError, err)
//          }
func (a *Assertions) Error(err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Error(a.t, err, msgAndArgs...)</span>
}

// ErrorAs asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func (a *Assertions) ErrorAs(err error, target interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ErrorAs(a.t, err, target, msgAndArgs...)</span>
}

// ErrorAsf asserts that at least one of the errors in err's chain matches target, and if so, sets target to that error value.
// This is a wrapper for errors.As.
func (a *Assertions) ErrorAsf(err error, target interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ErrorAsf(a.t, err, target, msg, args...)</span>
}

// ErrorContains asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        a.ErrorContains(err,  expectedErrorSubString)
func (a *Assertions) ErrorContains(theError error, contains string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">ErrorContains(a.t, theError, contains, msgAndArgs...)</span>
}

// ErrorContainsf asserts that a function returned an error (i.e. not `nil`)
// and that the error contains the specified substring.
//
//        actualObj, err := SomeFunction()
//        a.ErrorContainsf(err,  expectedErrorSubString, "error message %s", "formatted")
func (a *Assertions) ErrorContainsf(theError error, contains string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ErrorContainsf(a.t, theError, contains, msg, args...)</span>
}

// ErrorIs asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) ErrorIs(err error, target error, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ErrorIs(a.t, err, target, msgAndArgs...)</span>
}

// ErrorIsf asserts that at least one of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) ErrorIsf(err error, target error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">ErrorIsf(a.t, err, target, msg, args...)</span>
}

// Errorf asserts that a function returned an error (i.e. not `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.Errorf(err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedErrorf, err)
//          }
func (a *Assertions) Errorf(err error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Errorf(a.t, err, msg, args...)</span>
}

// Eventually asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Eventually(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// EventuallyWithT asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        a.EventuallyWithT(func(c *assert.CollectT) {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func (a *Assertions) EventuallyWithT(condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EventuallyWithT(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// EventuallyWithTf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick. In contrast to Eventually,
// it supplies a CollectT to the condition function, so that the condition
// function can use the CollectT to call other assertions.
// The condition is considered "met" if no errors are raised in a tick.
// The supplied CollectT collects all errors from one tick (if there are any).
// If the condition is not met before waitFor, the collected errors of
// the last tick are copied to t.
//
//        externalValue := false
//        go func() {
//                time.Sleep(8*time.Second)
//                externalValue = true
//        }()
//        a.EventuallyWithTf(func(c *assert.CollectT, "error message %s", "formatted") {
//                // add assertions as needed; any assertion failure will fail the current tick
//                assert.True(c, externalValue, "expected 'externalValue' to be true")
//        }, 10*time.Second, 1*time.Second, "external state has not changed to 'true'; still false")
func (a *Assertions) EventuallyWithTf(condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">EventuallyWithTf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Eventuallyf asserts that given condition will be met in waitFor time,
// periodically checking target function each tick.
//
//        a.Eventuallyf(func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func (a *Assertions) Eventuallyf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Eventuallyf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Exactly asserts that two objects are equal in value and type.
//
//        a.Exactly(int32(123), int64(123))
func (a *Assertions) Exactly(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Exactly(a.t, expected, actual, msgAndArgs...)</span>
}

// Exactlyf asserts that two objects are equal in value and type.
//
//        a.Exactlyf(int32(123), int64(123), "error message %s", "formatted")
func (a *Assertions) Exactlyf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Exactlyf(a.t, expected, actual, msg, args...)</span>
}

// Fail reports a failure through
func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Fail(a.t, failureMessage, msgAndArgs...)</span>
}

// FailNow fails test
func (a *Assertions) FailNow(failureMessage string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">FailNow(a.t, failureMessage, msgAndArgs...)</span>
}

// FailNowf fails test
func (a *Assertions) FailNowf(failureMessage string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">FailNowf(a.t, failureMessage, msg, args...)</span>
}

// Failf reports a failure through
func (a *Assertions) Failf(failureMessage string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Failf(a.t, failureMessage, msg, args...)</span>
}

// False asserts that the specified value is false.
//
//        a.False(myBool)
func (a *Assertions) False(value bool, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">False(a.t, value, msgAndArgs...)</span>
}

// Falsef asserts that the specified value is false.
//
//        a.Falsef(myBool, "error message %s", "formatted")
func (a *Assertions) Falsef(value bool, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Falsef(a.t, value, msg, args...)</span>
}

// FileExists checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func (a *Assertions) FileExists(path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">FileExists(a.t, path, msgAndArgs...)</span>
}

// FileExistsf checks whether a file exists in the given path. It also fails if
// the path points to a directory or there is an error when trying to check the file.
func (a *Assertions) FileExistsf(path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">FileExistsf(a.t, path, msg, args...)</span>
}

// Greater asserts that the first element is greater than the second
//
//        a.Greater(2, 1)
//        a.Greater(float64(2), float64(1))
//        a.Greater("b", "a")
func (a *Assertions) Greater(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Greater(a.t, e1, e2, msgAndArgs...)</span>
}

// GreaterOrEqual asserts that the first element is greater than or equal to the second
//
//        a.GreaterOrEqual(2, 1)
//        a.GreaterOrEqual(2, 2)
//        a.GreaterOrEqual("b", "a")
//        a.GreaterOrEqual("b", "b")
func (a *Assertions) GreaterOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">GreaterOrEqual(a.t, e1, e2, msgAndArgs...)</span>
}

// GreaterOrEqualf asserts that the first element is greater than or equal to the second
//
//        a.GreaterOrEqualf(2, 1, "error message %s", "formatted")
//        a.GreaterOrEqualf(2, 2, "error message %s", "formatted")
//        a.GreaterOrEqualf("b", "a", "error message %s", "formatted")
//        a.GreaterOrEqualf("b", "b", "error message %s", "formatted")
func (a *Assertions) GreaterOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">GreaterOrEqualf(a.t, e1, e2, msg, args...)</span>
}

// Greaterf asserts that the first element is greater than the second
//
//        a.Greaterf(2, 1, "error message %s", "formatted")
//        a.Greaterf(float64(2), float64(1), "error message %s", "formatted")
//        a.Greaterf("b", "a", "error message %s", "formatted")
func (a *Assertions) Greaterf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Greaterf(a.t, e1, e2, msg, args...)</span>
}

// HTTPBodyContains asserts that a specified handler returns a
// body that contains a string.
//
//        a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPBodyContains(a.t, handler, method, url, values, str, msgAndArgs...)</span>
}

// HTTPBodyContainsf asserts that a specified handler returns a
// body that contains a string.
//
//        a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPBodyContainsf(a.t, handler, method, url, values, str, msg, args...)</span>
}

// HTTPBodyNotContains asserts that a specified handler returns a
// body that does not contain a string.
//
//        a.HTTPBodyNotContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyNotContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPBodyNotContains(a.t, handler, method, url, values, str, msgAndArgs...)</span>
}

// HTTPBodyNotContainsf asserts that a specified handler returns a
// body that does not contain a string.
//
//        a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPBodyNotContainsf(a.t, handler, method, url, values, str, msg, args...)</span>
}

// HTTPError asserts that a specified handler returns an error status code.
//
//        a.HTTPError(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPError(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPErrorf asserts that a specified handler returns an error status code.
//
//        a.HTTPErrorf(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPErrorf(a.t, handler, method, url, values, msg, args...)</span>
}

// HTTPRedirect asserts that a specified handler returns a redirect status code.
//
//        a.HTTPRedirect(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPRedirect(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPRedirectf asserts that a specified handler returns a redirect status code.
//
//        a.HTTPRedirectf(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPRedirectf(a.t, handler, method, url, values, msg, args...)</span>
}

// HTTPStatusCode asserts that a specified handler returns a specified status code.
//
//        a.HTTPStatusCode(myHandler, "GET", "/notImplemented", nil, 501)
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPStatusCode(handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPStatusCode(a.t, handler, method, url, values, statuscode, msgAndArgs...)</span>
}

// HTTPStatusCodef asserts that a specified handler returns a specified status code.
//
//        a.HTTPStatusCodef(myHandler, "GET", "/notImplemented", nil, 501, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPStatusCodef(handler http.HandlerFunc, method string, url string, values url.Values, statuscode int, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPStatusCodef(a.t, handler, method, url, values, statuscode, msg, args...)</span>
}

// HTTPSuccess asserts that a specified handler returns a success status code.
//
//        a.HTTPSuccess(myHandler, "POST", "http://www.google.com", nil)
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPSuccess(a.t, handler, method, url, values, msgAndArgs...)</span>
}

// HTTPSuccessf asserts that a specified handler returns a success status code.
//
//        a.HTTPSuccessf(myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
//
// Returns whether the assertion was successful (true) or not (false).
func (a *Assertions) HTTPSuccessf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">HTTPSuccessf(a.t, handler, method, url, values, msg, args...)</span>
}

// Implements asserts that an object is implemented by the specified interface.
//
//        a.Implements((*MyInterface)(nil), new(MyObject))
func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Implements(a.t, interfaceObject, object, msgAndArgs...)</span>
}

// Implementsf asserts that an object is implemented by the specified interface.
//
//        a.Implementsf((*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func (a *Assertions) Implementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Implementsf(a.t, interfaceObject, object, msg, args...)</span>
}

// InDelta asserts that the two numerals are within delta of each other.
//
//        a.InDelta(math.Pi, 22/7.0, 0.01)
func (a *Assertions) InDelta(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">InDelta(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (a *Assertions) InDeltaMapValues(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InDeltaMapValues(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
func (a *Assertions) InDeltaMapValuesf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InDeltaMapValuesf(a.t, expected, actual, delta, msg, args...)</span>
}

// InDeltaSlice is the same as InDelta, except it compares two slices.
func (a *Assertions) InDeltaSlice(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InDeltaSlice(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// InDeltaSlicef is the same as InDelta, except it compares two slices.
func (a *Assertions) InDeltaSlicef(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InDeltaSlicef(a.t, expected, actual, delta, msg, args...)</span>
}

// InDeltaf asserts that the two numerals are within delta of each other.
//
//        a.InDeltaf(math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
func (a *Assertions) InDeltaf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InDeltaf(a.t, expected, actual, delta, msg, args...)</span>
}

// InEpsilon asserts that expected and actual have a relative error less than epsilon
func (a *Assertions) InEpsilon(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)</span>
}

// InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
func (a *Assertions) InEpsilonSlice(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InEpsilonSlice(a.t, expected, actual, epsilon, msgAndArgs...)</span>
}

// InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
func (a *Assertions) InEpsilonSlicef(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InEpsilonSlicef(a.t, expected, actual, epsilon, msg, args...)</span>
}

// InEpsilonf asserts that expected and actual have a relative error less than epsilon
func (a *Assertions) InEpsilonf(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">InEpsilonf(a.t, expected, actual, epsilon, msg, args...)</span>
}

// IsDecreasing asserts that the collection is decreasing
//
//        a.IsDecreasing([]int{2, 1, 0})
//        a.IsDecreasing([]float{2, 1})
//        a.IsDecreasing([]string{"b", "a"})
func (a *Assertions) IsDecreasing(object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsDecreasing(a.t, object, msgAndArgs...)</span>
}

// IsDecreasingf asserts that the collection is decreasing
//
//        a.IsDecreasingf([]int{2, 1, 0}, "error message %s", "formatted")
//        a.IsDecreasingf([]float{2, 1}, "error message %s", "formatted")
//        a.IsDecreasingf([]string{"b", "a"}, "error message %s", "formatted")
func (a *Assertions) IsDecreasingf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsDecreasingf(a.t, object, msg, args...)</span>
}

// IsIncreasing asserts that the collection is increasing
//
//        a.IsIncreasing([]int{1, 2, 3})
//        a.IsIncreasing([]float{1, 2})
//        a.IsIncreasing([]string{"a", "b"})
func (a *Assertions) IsIncreasing(object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsIncreasing(a.t, object, msgAndArgs...)</span>
}

// IsIncreasingf asserts that the collection is increasing
//
//        a.IsIncreasingf([]int{1, 2, 3}, "error message %s", "formatted")
//        a.IsIncreasingf([]float{1, 2}, "error message %s", "formatted")
//        a.IsIncreasingf([]string{"a", "b"}, "error message %s", "formatted")
func (a *Assertions) IsIncreasingf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsIncreasingf(a.t, object, msg, args...)</span>
}

// IsNonDecreasing asserts that the collection is not decreasing
//
//        a.IsNonDecreasing([]int{1, 1, 2})
//        a.IsNonDecreasing([]float{1, 2})
//        a.IsNonDecreasing([]string{"a", "b"})
func (a *Assertions) IsNonDecreasing(object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsNonDecreasing(a.t, object, msgAndArgs...)</span>
}

// IsNonDecreasingf asserts that the collection is not decreasing
//
//        a.IsNonDecreasingf([]int{1, 1, 2}, "error message %s", "formatted")
//        a.IsNonDecreasingf([]float{1, 2}, "error message %s", "formatted")
//        a.IsNonDecreasingf([]string{"a", "b"}, "error message %s", "formatted")
func (a *Assertions) IsNonDecreasingf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsNonDecreasingf(a.t, object, msg, args...)</span>
}

// IsNonIncreasing asserts that the collection is not increasing
//
//        a.IsNonIncreasing([]int{2, 1, 1})
//        a.IsNonIncreasing([]float{2, 1})
//        a.IsNonIncreasing([]string{"b", "a"})
func (a *Assertions) IsNonIncreasing(object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsNonIncreasing(a.t, object, msgAndArgs...)</span>
}

// IsNonIncreasingf asserts that the collection is not increasing
//
//        a.IsNonIncreasingf([]int{2, 1, 1}, "error message %s", "formatted")
//        a.IsNonIncreasingf([]float{2, 1}, "error message %s", "formatted")
//        a.IsNonIncreasingf([]string{"b", "a"}, "error message %s", "formatted")
func (a *Assertions) IsNonIncreasingf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsNonIncreasingf(a.t, object, msg, args...)</span>
}

// IsType asserts that the specified objects are of the same type.
func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">IsType(a.t, expectedType, object, msgAndArgs...)</span>
}

// IsTypef asserts that the specified objects are of the same type.
func (a *Assertions) IsTypef(expectedType interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">IsTypef(a.t, expectedType, object, msg, args...)</span>
}

// JSONEq asserts that two JSON strings are equivalent.
//
//        a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">JSONEq(a.t, expected, actual, msgAndArgs...)</span>
}

// JSONEqf asserts that two JSON strings are equivalent.
//
//        a.JSONEqf(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">JSONEqf(a.t, expected, actual, msg, args...)</span>
}

// Len asserts that the specified object has specific length.
// Len also fails if the object has a type that len() not accept.
//
//        a.Len(mySlice, 3)
func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Len(a.t, object, length, msgAndArgs...)</span>
}

// Lenf asserts that the specified object has specific length.
// Lenf also fails if the object has a type that len() not accept.
//
//        a.Lenf(mySlice, 3, "error message %s", "formatted")
func (a *Assertions) Lenf(object interface{}, length int, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Lenf(a.t, object, length, msg, args...)</span>
}

// Less asserts that the first element is less than the second
//
//        a.Less(1, 2)
//        a.Less(float64(1), float64(2))
//        a.Less("a", "b")
func (a *Assertions) Less(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Less(a.t, e1, e2, msgAndArgs...)</span>
}

// LessOrEqual asserts that the first element is less than or equal to the second
//
//        a.LessOrEqual(1, 2)
//        a.LessOrEqual(2, 2)
//        a.LessOrEqual("a", "b")
//        a.LessOrEqual("b", "b")
func (a *Assertions) LessOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">LessOrEqual(a.t, e1, e2, msgAndArgs...)</span>
}

// LessOrEqualf asserts that the first element is less than or equal to the second
//
//        a.LessOrEqualf(1, 2, "error message %s", "formatted")
//        a.LessOrEqualf(2, 2, "error message %s", "formatted")
//        a.LessOrEqualf("a", "b", "error message %s", "formatted")
//        a.LessOrEqualf("b", "b", "error message %s", "formatted")
func (a *Assertions) LessOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">LessOrEqualf(a.t, e1, e2, msg, args...)</span>
}

// Lessf asserts that the first element is less than the second
//
//        a.Lessf(1, 2, "error message %s", "formatted")
//        a.Lessf(float64(1), float64(2), "error message %s", "formatted")
//        a.Lessf("a", "b", "error message %s", "formatted")
func (a *Assertions) Lessf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Lessf(a.t, e1, e2, msg, args...)</span>
}

// Negative asserts that the specified element is negative
//
//        a.Negative(-1)
//        a.Negative(-1.23)
func (a *Assertions) Negative(e interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Negative(a.t, e, msgAndArgs...)</span>
}

// Negativef asserts that the specified element is negative
//
//        a.Negativef(-1, "error message %s", "formatted")
//        a.Negativef(-1.23, "error message %s", "formatted")
func (a *Assertions) Negativef(e interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Negativef(a.t, e, msg, args...)</span>
}

// Never asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
func (a *Assertions) Never(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Never(a.t, condition, waitFor, tick, msgAndArgs...)</span>
}

// Neverf asserts that the given condition doesn't satisfy in waitFor time,
// periodically checking the target function each tick.
//
//        a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
func (a *Assertions) Neverf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Neverf(a.t, condition, waitFor, tick, msg, args...)</span>
}

// Nil asserts that the specified object is nil.
//
//        a.Nil(err)
func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Nil(a.t, object, msgAndArgs...)</span>
}

// Nilf asserts that the specified object is nil.
//
//        a.Nilf(err, "error message %s", "formatted")
func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Nilf(a.t, object, msg, args...)</span>
}

// NoDirExists checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func (a *Assertions) NoDirExists(path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NoDirExists(a.t, path, msgAndArgs...)</span>
}

// NoDirExistsf checks whether a directory does not exist in the given path.
// It fails if the path points to an existing _directory_ only.
func (a *Assertions) NoDirExistsf(path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NoDirExistsf(a.t, path, msg, args...)</span>
}

// NoError asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.NoError(err) {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NoError(a.t, err, msgAndArgs...)</span>
}

// NoErrorf asserts that a function returned no error (i.e. `nil`).
//
//          actualObj, err := SomeFunction()
//          if a.NoErrorf(err, "error message %s", "formatted") {
//                   assert.Equal(t, expectedObj, actualObj)
//          }
func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NoErrorf(a.t, err, msg, args...)</span>
}

// NoFileExists checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func (a *Assertions) NoFileExists(path string, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NoFileExists(a.t, path, msgAndArgs...)</span>
}

// NoFileExistsf checks whether a file does not exist in a given path. It fails
// if the path points to an existing _file_ only.
func (a *Assertions) NoFileExistsf(path string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NoFileExistsf(a.t, path, msg, args...)</span>
}

// NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        a.NotContains("Hello World", "Earth")
//        a.NotContains(["Hello", "World"], "Earth")
//        a.NotContains({"Hello": "World"}, "Earth")
func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotContains(a.t, s, contains, msgAndArgs...)</span>
}

// NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
// specified substring or element.
//
//        a.NotContainsf("Hello World", "Earth", "error message %s", "formatted")
//        a.NotContainsf(["Hello", "World"], "Earth", "error message %s", "formatted")
//        a.NotContainsf({"Hello": "World"}, "Earth", "error message %s", "formatted")
func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotContainsf(a.t, s, contains, msg, args...)</span>
}

// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// a.NotElementsMatch([1, 1, 2, 3], [1, 1, 2, 3]) -&gt; false
//
// a.NotElementsMatch([1, 1, 2, 3], [1, 2, 3]) -&gt; true
//
// a.NotElementsMatch([1, 2, 3], [1, 2, 4]) -&gt; true
func (a *Assertions) NotElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotElementsMatch(a.t, listA, listB, msgAndArgs...)</span>
}

// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
// the number of appearances of each of them in both lists should not match.
// This is an inverse of ElementsMatch.
//
// a.NotElementsMatchf([1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -&gt; false
//
// a.NotElementsMatchf([1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -&gt; true
//
// a.NotElementsMatchf([1, 2, 3], [1, 2, 4], "error message %s", "formatted") -&gt; true
func (a *Assertions) NotElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotElementsMatchf(a.t, listA, listB, msg, args...)</span>
}

// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if a.NotEmpty(obj) {
//          assert.Equal(t, "two", obj[1])
//        }
func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotEmpty(a.t, object, msgAndArgs...)</span>
}

// NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
// a slice or a channel with len == 0.
//
//        if a.NotEmptyf(obj, "error message %s", "formatted") {
//          assert.Equal(t, "two", obj[1])
//        }
func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotEmptyf(a.t, object, msg, args...)</span>
}

// NotEqual asserts that the specified values are NOT equal.
//
//        a.NotEqual(obj1, obj2)
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotEqual(a.t, expected, actual, msgAndArgs...)</span>
}

// NotEqualValues asserts that two objects are not equal even when converted to the same type
//
//        a.NotEqualValues(obj1, obj2)
func (a *Assertions) NotEqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotEqualValues(a.t, expected, actual, msgAndArgs...)</span>
}

// NotEqualValuesf asserts that two objects are not equal even when converted to the same type
//
//        a.NotEqualValuesf(obj1, obj2, "error message %s", "formatted")
func (a *Assertions) NotEqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotEqualValuesf(a.t, expected, actual, msg, args...)</span>
}

// NotEqualf asserts that the specified values are NOT equal.
//
//        a.NotEqualf(obj1, obj2, "error message %s", "formatted")
//
// Pointer variable equality is determined based on the equality of the
// referenced values (as opposed to the memory addresses).
func (a *Assertions) NotEqualf(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotEqualf(a.t, expected, actual, msg, args...)</span>
}

// NotErrorAs asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func (a *Assertions) NotErrorAs(err error, target interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotErrorAs(a.t, err, target, msgAndArgs...)</span>
}

// NotErrorAsf asserts that none of the errors in err's chain matches target,
// but if so, sets target to that error value.
func (a *Assertions) NotErrorAsf(err error, target interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotErrorAsf(a.t, err, target, msg, args...)</span>
}

// NotErrorIs asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) NotErrorIs(err error, target error, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotErrorIs(a.t, err, target, msgAndArgs...)</span>
}

// NotErrorIsf asserts that none of the errors in err's chain matches target.
// This is a wrapper for errors.Is.
func (a *Assertions) NotErrorIsf(err error, target error, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotErrorIsf(a.t, err, target, msg, args...)</span>
}

// NotImplements asserts that an object does not implement the specified interface.
//
//        a.NotImplements((*MyInterface)(nil), new(MyObject))
func (a *Assertions) NotImplements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotImplements(a.t, interfaceObject, object, msgAndArgs...)</span>
}

// NotImplementsf asserts that an object does not implement the specified interface.
//
//        a.NotImplementsf((*MyInterface)(nil), new(MyObject), "error message %s", "formatted")
func (a *Assertions) NotImplementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotImplementsf(a.t, interfaceObject, object, msg, args...)</span>
}

// NotNil asserts that the specified object is not nil.
//
//        a.NotNil(err)
func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotNil(a.t, object, msgAndArgs...)</span>
}

// NotNilf asserts that the specified object is not nil.
//
//        a.NotNilf(err, "error message %s", "formatted")
func (a *Assertions) NotNilf(object interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotNilf(a.t, object, msg, args...)</span>
}

// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        a.NotPanics(func(){ RemainCalm() })
func (a *Assertions) NotPanics(f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotPanics(a.t, f, msgAndArgs...)</span>
}

// NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
//
//        a.NotPanicsf(func(){ RemainCalm() }, "error message %s", "formatted")
func (a *Assertions) NotPanicsf(f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotPanicsf(a.t, f, msg, args...)</span>
}

// NotRegexp asserts that a specified regexp does not match a string.
//
//        a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
//        a.NotRegexp("^start", "it's not starting")
func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotRegexp(a.t, rx, str, msgAndArgs...)</span>
}

// NotRegexpf asserts that a specified regexp does not match a string.
//
//        a.NotRegexpf(regexp.MustCompile("starts"), "it's starting", "error message %s", "formatted")
//        a.NotRegexpf("^start", "it's not starting", "error message %s", "formatted")
func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotRegexpf(a.t, rx, str, msg, args...)</span>
}

// NotSame asserts that two pointers do not reference the same object.
//
//        a.NotSame(ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) NotSame(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotSame(a.t, expected, actual, msgAndArgs...)</span>
}

// NotSamef asserts that two pointers do not reference the same object.
//
//        a.NotSamef(ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) NotSamef(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotSamef(a.t, expected, actual, msg, args...)</span>
}

// NotSubset asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        a.NotSubset([1, 3, 4], [1, 2])
//        a.NotSubset({"x": 1, "y": 2}, {"z": 3})
func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotSubset(a.t, list, subset, msgAndArgs...)</span>
}

// NotSubsetf asserts that the specified list(array, slice...) or map does NOT
// contain all elements given in the specified subset list(array, slice...) or
// map.
//
//        a.NotSubsetf([1, 3, 4], [1, 2], "error message %s", "formatted")
//        a.NotSubsetf({"x": 1, "y": 2}, {"z": 3}, "error message %s", "formatted")
func (a *Assertions) NotSubsetf(list interface{}, subset interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotSubsetf(a.t, list, subset, msg, args...)</span>
}

// NotZero asserts that i is not the zero value for its type.
func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">NotZero(a.t, i, msgAndArgs...)</span>
}

// NotZerof asserts that i is not the zero value for its type.
func (a *Assertions) NotZerof(i interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">NotZerof(a.t, i, msg, args...)</span>
}

// Panics asserts that the code inside the specified PanicTestFunc panics.
//
//        a.Panics(func(){ GoCrazy() })
func (a *Assertions) Panics(f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Panics(a.t, f, msgAndArgs...)</span>
}

// PanicsWithError asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        a.PanicsWithError("crazy error", func(){ GoCrazy() })
func (a *Assertions) PanicsWithError(errString string, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">PanicsWithError(a.t, errString, f, msgAndArgs...)</span>
}

// PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
// panics, and that the recovered panic value is an error that satisfies the
// EqualError comparison.
//
//        a.PanicsWithErrorf("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) PanicsWithErrorf(errString string, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">PanicsWithErrorf(a.t, errString, f, msg, args...)</span>
}

// PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        a.PanicsWithValue("crazy error", func(){ GoCrazy() })
func (a *Assertions) PanicsWithValue(expected interface{}, f assert.PanicTestFunc, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">PanicsWithValue(a.t, expected, f, msgAndArgs...)</span>
}

// PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
// the recovered panic value equals the expected panic value.
//
//        a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) PanicsWithValuef(expected interface{}, f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">PanicsWithValuef(a.t, expected, f, msg, args...)</span>
}

// Panicsf asserts that the code inside the specified PanicTestFunc panics.
//
//        a.Panicsf(func(){ GoCrazy() }, "error message %s", "formatted")
func (a *Assertions) Panicsf(f assert.PanicTestFunc, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Panicsf(a.t, f, msg, args...)</span>
}

// Positive asserts that the specified element is positive
//
//        a.Positive(1)
//        a.Positive(1.23)
func (a *Assertions) Positive(e interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Positive(a.t, e, msgAndArgs...)</span>
}

// Positivef asserts that the specified element is positive
//
//        a.Positivef(1, "error message %s", "formatted")
//        a.Positivef(1.23, "error message %s", "formatted")
func (a *Assertions) Positivef(e interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Positivef(a.t, e, msg, args...)</span>
}

// Regexp asserts that a specified regexp matches a string.
//
//        a.Regexp(regexp.MustCompile("start"), "it's starting")
//        a.Regexp("start...$", "it's not starting")
func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Regexp(a.t, rx, str, msgAndArgs...)</span>
}

// Regexpf asserts that a specified regexp matches a string.
//
//        a.Regexpf(regexp.MustCompile("start"), "it's starting", "error message %s", "formatted")
//        a.Regexpf("start...$", "it's not starting", "error message %s", "formatted")
func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Regexpf(a.t, rx, str, msg, args...)</span>
}

// Same asserts that two pointers reference the same object.
//
//        a.Same(ptr1, ptr2)
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) Same(expected interface{}, actual interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Same(a.t, expected, actual, msgAndArgs...)</span>
}

// Samef asserts that two pointers reference the same object.
//
//        a.Samef(ptr1, ptr2, "error message %s", "formatted")
//
// Both arguments must be pointer variables. Pointer variable sameness is
// determined based on the equality of both type and value.
func (a *Assertions) Samef(expected interface{}, actual interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Samef(a.t, expected, actual, msg, args...)</span>
}

// Subset asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        a.Subset([1, 2, 3], [1, 2])
//        a.Subset({"x": 1, "y": 2}, {"x": 1})
func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Subset(a.t, list, subset, msgAndArgs...)</span>
}

// Subsetf asserts that the specified list(array, slice...) or map contains all
// elements given in the specified subset list(array, slice...) or map.
//
//        a.Subsetf([1, 2, 3], [1, 2], "error message %s", "formatted")
//        a.Subsetf({"x": 1, "y": 2}, {"x": 1}, "error message %s", "formatted")
func (a *Assertions) Subsetf(list interface{}, subset interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Subsetf(a.t, list, subset, msg, args...)</span>
}

// True asserts that the specified value is true.
//
//        a.True(myBool)
func (a *Assertions) True(value bool, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">True(a.t, value, msgAndArgs...)</span>
}

// Truef asserts that the specified value is true.
//
//        a.Truef(myBool, "error message %s", "formatted")
func (a *Assertions) Truef(value bool, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Truef(a.t, value, msg, args...)</span>
}

// WithinDuration asserts that the two times are within duration delta of each other.
//
//        a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
func (a *Assertions) WithinDuration(expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">WithinDuration(a.t, expected, actual, delta, msgAndArgs...)</span>
}

// WithinDurationf asserts that the two times are within duration delta of each other.
//
//        a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
func (a *Assertions) WithinDurationf(expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">WithinDurationf(a.t, expected, actual, delta, msg, args...)</span>
}

// WithinRange asserts that a time is within a time range (inclusive).
//
//        a.WithinRange(time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second))
func (a *Assertions) WithinRange(actual time.Time, start time.Time, end time.Time, msgAndArgs ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">WithinRange(a.t, actual, start, end, msgAndArgs...)</span>
}

// WithinRangef asserts that a time is within a time range (inclusive).
//
//        a.WithinRangef(time.Now(), time.Now().Add(-time.Second), time.Now().Add(time.Second), "error message %s", "formatted")
func (a *Assertions) WithinRangef(actual time.Time, start time.Time, end time.Time, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">WithinRangef(a.t, actual, start, end, msg, args...)</span>
}

// YAMLEq asserts that two YAML strings are equivalent.
func (a *Assertions) YAMLEq(expected string, actual string, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">YAMLEq(a.t, expected, actual, msgAndArgs...)</span>
}

// YAMLEqf asserts that two YAML strings are equivalent.
func (a *Assertions) YAMLEqf(expected string, actual string, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">YAMLEqf(a.t, expected, actual, msg, args...)</span>
}

// Zero asserts that i is the zero value for its type.
func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov8" title="1">{
                h.Helper()
        }</span>
        <span class="cov8" title="1">Zero(a.t, i, msgAndArgs...)</span>
}

// Zerof asserts that i is the zero value for its type.
func (a *Assertions) Zerof(i interface{}, msg string, args ...interface{}) <span class="cov0" title="0">{
        if h, ok := a.t.(tHelper); ok </span><span class="cov0" title="0">{
                h.Helper()
        }</span>
        <span class="cov0" title="0">Zerof(a.t, i, msg, args...)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package suite

import "time"

// SuiteInformation stats stores stats for the whole suite execution.
type SuiteInformation struct {
        Start, End time.Time
        TestStats  map[string]*TestInformation
}

// TestInformation stores information about the execution of each test.
type TestInformation struct {
        TestName   string
        Start, End time.Time
        Passed     bool
}

func newSuiteInformation() *SuiteInformation <span class="cov8" title="1">{
        testStats := make(map[string]*TestInformation)

        return &amp;SuiteInformation{
                TestStats: testStats,
        }
}</span>

func (s SuiteInformation) start(testName string) <span class="cov8" title="1">{
        s.TestStats[testName] = &amp;TestInformation{
                TestName: testName,
                Start:    time.Now(),
        }
}</span>

func (s SuiteInformation) end(testName string, passed bool) <span class="cov8" title="1">{
        s.TestStats[testName].End = time.Now()
        s.TestStats[testName].Passed = passed
}</span>

func (s SuiteInformation) Passed() bool <span class="cov8" title="1">{
        for _, stats := range s.TestStats </span><span class="cov8" title="1">{
                if !stats.Passed </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package suite

import (
        "flag"
        "fmt"
        "os"
        "reflect"
        "regexp"
        "runtime/debug"
        "sync"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

var allTestsFilter = func(_, _ string) (bool, error) <span class="cov0" title="0">{ return true, nil }</span>
var matchMethod = flag.String("testify.m", "", "regular expression to select tests of the testify suite to run")

// Suite is a basic testing suite with methods for storing and
// retrieving the current *testing.T context.
type Suite struct {
        *assert.Assertions

        mu      sync.RWMutex
        require *require.Assertions
        t       *testing.T

        // Parent suite to have access to the implemented methods of parent struct
        s TestingSuite
}

// T retrieves the current *testing.T context.
func (suite *Suite) T() *testing.T <span class="cov8" title="1">{
        suite.mu.RLock()
        defer suite.mu.RUnlock()
        return suite.t
}</span>

// SetT sets the current *testing.T context.
func (suite *Suite) SetT(t *testing.T) <span class="cov8" title="1">{
        suite.mu.Lock()
        defer suite.mu.Unlock()
        suite.t = t
        suite.Assertions = assert.New(t)
        suite.require = require.New(t)
}</span>

// SetS needs to set the current test suite as parent
// to get access to the parent methods
func (suite *Suite) SetS(s TestingSuite) <span class="cov8" title="1">{
        suite.s = s
}</span>

// Require returns a require context for suite.
func (suite *Suite) Require() *require.Assertions <span class="cov8" title="1">{
        suite.mu.Lock()
        defer suite.mu.Unlock()
        if suite.require == nil </span><span class="cov8" title="1">{
                panic("'Require' must not be called before 'Run' or 'SetT'")</span>
        }
        <span class="cov8" title="1">return suite.require</span>
}

// Assert returns an assert context for suite.  Normally, you can call
// `suite.NoError(expected, actual)`, but for situations where the embedded
// methods are overridden (for example, you might want to override
// assert.Assertions with require.Assertions), this method is provided so you
// can call `suite.Assert().NoError()`.
func (suite *Suite) Assert() *assert.Assertions <span class="cov8" title="1">{
        suite.mu.Lock()
        defer suite.mu.Unlock()
        if suite.Assertions == nil </span><span class="cov8" title="1">{
                panic("'Assert' must not be called before 'Run' or 'SetT'")</span>
        }
        <span class="cov8" title="1">return suite.Assertions</span>
}

func recoverAndFailOnPanic(t *testing.T) <span class="cov8" title="1">{
        t.Helper()
        r := recover()
        failOnPanic(t, r)
}</span>

func failOnPanic(t *testing.T, r interface{}) <span class="cov8" title="1">{
        t.Helper()
        if r != nil </span><span class="cov8" title="1">{
                t.Errorf("test panicked: %v\n%s", r, debug.Stack())
                t.FailNow()
        }</span>
}

// Run provides suite functionality around golang subtests.  It should be
// called in place of t.Run(name, func(t *testing.T)) in test suite code.
// The passed-in func will be executed as a subtest with a fresh instance of t.
// Provides compatibility with go test pkg -run TestSuite/TestName/SubTestName.
func (suite *Suite) Run(name string, subtest func()) bool <span class="cov8" title="1">{
        oldT := suite.T()

        return oldT.Run(name, func(t *testing.T) </span><span class="cov8" title="1">{
                suite.SetT(t)
                defer suite.SetT(oldT)

                defer recoverAndFailOnPanic(t)

                if setupSubTest, ok := suite.s.(SetupSubTest); ok </span><span class="cov8" title="1">{
                        setupSubTest.SetupSubTest()
                }</span>

                <span class="cov8" title="1">if tearDownSubTest, ok := suite.s.(TearDownSubTest); ok </span><span class="cov8" title="1">{
                        defer tearDownSubTest.TearDownSubTest()
                }</span>

                <span class="cov8" title="1">subtest()</span>
        })
}

// Run takes a testing suite and runs all of the tests attached
// to it.
func Run(t *testing.T, suite TestingSuite) <span class="cov8" title="1">{
        defer recoverAndFailOnPanic(t)

        suite.SetT(t)
        suite.SetS(suite)

        var suiteSetupDone bool

        var stats *SuiteInformation
        if _, ok := suite.(WithStats); ok </span><span class="cov8" title="1">{
                stats = newSuiteInformation()
        }</span>

        <span class="cov8" title="1">tests := []testing.InternalTest{}
        methodFinder := reflect.TypeOf(suite)
        suiteName := methodFinder.Elem().Name()

        for i := 0; i &lt; methodFinder.NumMethod(); i++ </span><span class="cov8" title="1">{
                method := methodFinder.Method(i)

                ok, err := methodFilter(method.Name)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testify: invalid regexp for -m: %s\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !suiteSetupDone </span><span class="cov8" title="1">{
                        if stats != nil </span><span class="cov8" title="1">{
                                stats.Start = time.Now()
                        }</span>

                        <span class="cov8" title="1">if setupAllSuite, ok := suite.(SetupAllSuite); ok </span><span class="cov8" title="1">{
                                setupAllSuite.SetupSuite()
                        }</span>

                        <span class="cov8" title="1">suiteSetupDone = true</span>
                }

                <span class="cov8" title="1">test := testing.InternalTest{
                        Name: method.Name,
                        F: func(t *testing.T) </span><span class="cov8" title="1">{
                                parentT := suite.T()
                                suite.SetT(t)
                                defer recoverAndFailOnPanic(t)
                                defer func() </span><span class="cov8" title="1">{
                                        t.Helper()

                                        r := recover()

                                        if stats != nil </span><span class="cov8" title="1">{
                                                passed := !t.Failed() &amp;&amp; r == nil
                                                stats.end(method.Name, passed)
                                        }</span>

                                        <span class="cov8" title="1">if afterTestSuite, ok := suite.(AfterTest); ok </span><span class="cov8" title="1">{
                                                afterTestSuite.AfterTest(suiteName, method.Name)
                                        }</span>

                                        <span class="cov8" title="1">if tearDownTestSuite, ok := suite.(TearDownTestSuite); ok </span><span class="cov8" title="1">{
                                                tearDownTestSuite.TearDownTest()
                                        }</span>

                                        <span class="cov8" title="1">suite.SetT(parentT)
                                        failOnPanic(t, r)</span>
                                }()

                                <span class="cov8" title="1">if setupTestSuite, ok := suite.(SetupTestSuite); ok </span><span class="cov8" title="1">{
                                        setupTestSuite.SetupTest()
                                }</span>
                                <span class="cov8" title="1">if beforeTestSuite, ok := suite.(BeforeTest); ok </span><span class="cov8" title="1">{
                                        beforeTestSuite.BeforeTest(methodFinder.Elem().Name(), method.Name)
                                }</span>

                                <span class="cov8" title="1">if stats != nil </span><span class="cov8" title="1">{
                                        stats.start(method.Name)
                                }</span>

                                <span class="cov8" title="1">method.Func.Call([]reflect.Value{reflect.ValueOf(suite)})</span>
                        },
                }
                <span class="cov8" title="1">tests = append(tests, test)</span>
        }
        <span class="cov8" title="1">if suiteSetupDone </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if tearDownAllSuite, ok := suite.(TearDownAllSuite); ok </span><span class="cov8" title="1">{
                                tearDownAllSuite.TearDownSuite()
                        }</span>

                        <span class="cov8" title="1">if suiteWithStats, measureStats := suite.(WithStats); measureStats </span><span class="cov8" title="1">{
                                stats.End = time.Now()
                                suiteWithStats.HandleStats(suiteName, stats)
                        }</span>
                }()
        }

        <span class="cov8" title="1">runTests(t, tests)</span>
}

// Filtering method according to set regular expression
// specified command-line argument -m
func methodFilter(name string) (bool, error) <span class="cov8" title="1">{
        if ok, _ := regexp.MatchString("^Test", name); !ok </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return regexp.MatchString(*matchMethod, name)</span>
}

func runTests(t testing.TB, tests []testing.InternalTest) <span class="cov8" title="1">{
        if len(tests) == 0 </span><span class="cov8" title="1">{
                t.Log("warning: no tests to run")
                return
        }</span>

        <span class="cov8" title="1">r, ok := t.(runner)
        if !ok </span><span class="cov0" title="0">{ // backwards compatibility with Go 1.6 and below
                if !testing.RunTests(allTestsFilter, tests) </span><span class="cov0" title="0">{
                        t.Fail()
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">for _, test := range tests </span><span class="cov8" title="1">{
                r.Run(test.Name, test.F)
        }</span>
}

type runner interface {
        Run(name string, f func(t *testing.T)) bool
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
